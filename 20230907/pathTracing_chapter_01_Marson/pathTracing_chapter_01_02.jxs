<jittershader name="default">
	<description>Default Slab </description>
	
	<param name="MVP" type="mat4" state="MODELVIEW_PROJECTION_MATRIX" />
	<param name="pos" type="vec3" state="POSITION" />
	<param name="uv" type="vec2" state="TEXCOORD" />
	<param name="viewPort" type="vec2" state="VIEWPORT" />
	<param name="eye" type="vec3" state="CAMERA_POSITION" />
	
	<language name="glsl" version="1.5">
		
		<bind param="MVP" program="vp" />

		<bind param="pos" program="vp" />
		<bind param="uv" program="vp" />
		<bind param="viewPort" program="fp" />
		<bind param="eye" program="fp" />

		<program name="vp" type="vertex"  >
		<![CDATA[
			#version 330 core
			
			in vec3 pos; // position is pos
			in vec2 uv;

			out jit_PerVertex {
				vec2 uv; //texcoord is uv
			} jit_out;
			uniform mat4 MVP;
			
			void main(void) {
				gl_Position = MVP*vec4(pos, 1.);
				jit_out.uv = uv;

			}
		]]>
		</program>
		
		<program name="fp" type="fragment"  >
		<![CDATA[
#version 330 core

in jit_PerVertex {
	vec2 uv;
} jit_in;

layout (location = 0) out vec4 outColor;

uniform vec2 viewPort;
uniform vec3 eye;

struct rayInfo{
	vec3 origin;
	vec3 dir;
};

struct hitInfo{
	float t0;
	vec3 nor;
};

//Alan Wolfe Shadertoy https://www.shadertoy.com/view/tsBBWW (modified)
bool TestSphereTrace(in rayInfo ray, inout hitInfo hit, in vec4 sphere)
{
	//get the vector from the center of this sphere to where the ray begins.
	vec3 m = ray.origin - sphere.xyz;

    //get the dot product of the above vector and the ray's vector
	float b = dot(m, ray.dir);

	float c = dot(m, m) - sphere.w * sphere.w;

	//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
	if(c > 0.0 && b > 0.0)
		return false;

	//calculate discriminant
	float discr = b * b - c;

	//a negative discriminant corresponds to ray missing sphere
	if(discr < 0.0)
		return false;
    
	//ray now found to intersect sphere, compute smallest t value of intersection
    bool fromInside = false;
	float dist = -b - sqrt(discr);
    if (dist < 0.0f)
    {
        fromInside = true;
        dist = -b + sqrt(discr);
    }
    
	if (dist < hit.t0) //(dist > c_minimumRayHitTime && dist < hit.t0)
    {
        hit.t0 = dist;        
        hit.nor = normalize((ray.origin+ray.dir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);
        return true;
    }
    
    return false;
}

void computeFirstRay(out rayInfo ray) {
	vec2 screenPos = jit_in.uv*2-1;
	float ratio = viewPort.x / viewPort.y;
	screenPos.x *= ratio;

	ray.origin = eye;
	vec3 pixPos = vec3(screenPos, -4);
	ray.dir = normalize(pixPos - ray.origin);
}

vec3 rayTrace(in rayInfo ray, in hitInfo hit){

	hit.t0 = 1e8;
	vec3 center = vec3(-0.5, 0., -6);
	float radius = 0.7;
	if(TestSphereTrace(ray, hit, vec4(center, radius))){
		return vec3(1, 0, 0);
	}
	return vec3(0.);
}

void main(void) {

	rayInfo ray;
	hitInfo hit;

	computeFirstRay(ray);
	outColor.rgb = rayTrace(ray, hit);
	outColor.a = 1;
}
		]]>
		</program>
	</language>
</jittershader>
