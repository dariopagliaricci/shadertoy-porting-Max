<jittershader name="TFLocomotion">
	<description>Basic Transform Feedback Locomotion</description>
	<param name="inPos" type="vec3" state="POSITION" />
	<param name="inOldPos" type="vec3" state="NORMAL" />
	<param name="id" type="vec3" state="VERTEX_ATTR0" />
	<param name="trails" type="int" default="0" />


	<param name="senseAngle" type="float" default="1.2" />
	<param name="senseDistance" type="float" default="10." />
	<param name="rotationAngle" type="float" default="1.5" />
	<param name="speed" type="float" default="1." />

	<language name="glsl" version="1.5">
		<bind param="inPos" program="vp" />
		<bind param="inOldPos" program="vp" />
		<bind param="id" program="vp" />
		<bind param="trails" program="vp" />

		<bind param="senseAngle" program="vp" />
		<bind param="senseDistance" program="vp" />
		<bind param="rotationAngle" program="vp" />
		<bind param="speed" program="vp" />

		<program name="vp" type="vertex">
<![CDATA[
#version 330 core
#define TWOPI 6.28318530718

in vec3 inPos;
in vec3 inOldPos;
in vec3 id;

out vec3 outPos;
out vec3 outOldPos;
out vec3 idOut;

uniform sampler2DRect trails;

uniform float senseAngle;
uniform float senseDistance;
uniform float rotationAngle;
uniform float speed;

float hash(float n) { return fract(sin(n) * 1e4); }
float noise(float x) {
	float i = floor(x);
	float f = fract(x);
	float u = f * f * (3. -2. *f);
	return mix(hash(i), hash(i + 1.), u);
}

float sense(vec2 pos, float angle, float sensorAngle, float sensorDistance)
{
	float  sensorOrientation = angle + sensorAngle;
	vec2   sensorPlacement = vec2(cos(sensorOrientation), sin(sensorOrientation));
		   sensorPlacement *= sensorDistance;
		   sensorPlacement += pos;

	int sensorSize = 2;
	vec2	co;
	float	sum = 0.;
	for(int c = -sensorSize; c <= sensorSize; c++){
		for(int r = -sensorSize; r <= sensorSize; r++){

			co = sensorPlacement + vec2(r, c);
			sum += texture(trails, vec2(co.x, 1079. - co.y)).r;
		}
	}
	return sum;
}

float changeDirection(float angle, float L, float C, float R, float random)
{
	if(C > L && C > R){
		angle += 0.;
	} 
	else if (L > C && R > C){
		angle += (random - 0.5) * TWOPI * rotationAngle;
	}
	else if (R > C && C > L){
		angle -= random * TWOPI * rotationAngle;
	}
	else if (L > C && C > R){
		angle += random * TWOPI * rotationAngle;
	}
	return angle;
}

void main() {	

	vec2 	pos = inPos.xy;
	float 	angle = inPos.z;

	float 	random = noise(pos.x * 1920. + pos.y + id.x);

	float	L = sense(pos, angle, senseAngle, senseDistance);
	float	C = sense(pos, angle, 0., senseDistance);
	float	R = sense(pos, angle, -senseAngle, senseDistance);

	angle = changeDirection(angle, L, C, R, random);

	vec2	dir = vec2(cos(angle), sin(angle));
	dir *= speed;
	pos += dir;

	if(pos.x < 0. || pos.x > 1919. || pos.y < 0. || pos.y > 1079.){

		pos.x = min(1919., 
				max(0., pos.x));
		pos.y = min(1079., 
				max(0., pos.y)); 
		angle = random * TWOPI;
	}

	outPos = vec3(pos, angle);
	outOldPos = vec3(inPos.xy, 0.);
	idOut = id;

}
]]>
		</program>
		<program name="fp" type="fragment"  >
		<![CDATA[
#version 330 core
void main() 
{
}
		]]>
		</program>
	</language>
</jittershader>

