<jittershader name="default">
	<description>Default Slab </description>

	<param name="MVP" type="mat4" state="MODELVIEW_PROJECTION_MATRIX" />
	<param name="pos" type="vec3" state="POSITION" />
	<param name="uv" type="vec2" state="TEXCOORD" />
	<param name="viewPort" type="vec2" state="VIEWPORT" />
	<param name="eye" type="vec3" state="CAMERA_POSITION" />

	<param name="zoom" type="float" default="0.0" />

	<language name="glsl" version="1.5">

		<bind param="MVP" program="vp" />
		<bind param="pos" program="vp" />
		<bind param="uv" program="vp" />

		<bind param="viewPort" program="fp" />
		<bind param="eye" program="fp" />
		<bind param="zoom" program="fp" />

		<program name="vp" type="vertex"  >
		<![CDATA[
			#version 330 core
			
			in vec3 pos;
			in vec2 uv;

			out jit_PerVertex {
				vec2 uv;

			} jit_out;
			uniform mat4 MVP;

			
			void main(void) {
				gl_Position = MVP*vec4(pos, 1.);
				jit_out.uv = uv;

			}
		]]>
		</program>
		
<program name="fp" type="fragment"  >
<![CDATA[
#version 330 core

in jit_PerVertex {
	vec2 uv;

} jit_in;
layout (location = 0) out vec4 outColor;

uniform vec2 viewPort;
uniform vec3 eye;
uniform float zoom;

// Basic Camera System
// Credits to Martijn Steinrucken and Matteo Marson
//"The art of code"
// https://www.youtube.com/watch?v=PBxuVlp7nuM

float DistLine(vec3 ro, vec3 rd, vec3 p) {
	return length(cross(p-ro, rd))/length(rd);
}

float DrawPoint(vec3 ro, vec3 rd, vec3 p) {
	float d = DistLine(ro, rd, p);
    d = smoothstep(.09, .08, d);
    return d;
}

void main()
{
    
	vec2 screenPos = jit_in.uv * 2 - 1;
	float ratio = viewPort.x / viewPort.y;
	screenPos.x *= ratio;
    
    vec3 ro = eye;// ray origin
    
    vec3 lookAt = vec3(.0); //target
    
    // float zoom = 1.;
    
    vec3 f = normalize(lookAt-ro);//fwd //front
    vec3 r = cross(vec3(0., 1., 0.), f);//right
    vec3 u = cross(f, r);//up

    vec3 pixPos = vec3(screenPos, zoom);//vec3 c = ro + f*zoom;
    vec3 rd = normalize(pixPos.x*r + pixPos.y*u + pixPos.z*f);//vec3 i = c + uv.x*r + uv.y*u;
    
    // vec3 c = ro + f*zoom;
    // vec3 i = c + uv.x*r + uv.y*u;
    // vec3 rd = i-ro;
    
    float d = 0.;
    
    d += DrawPoint(ro, rd, vec3(0., 0., 0.));
    d += DrawPoint(ro, rd, vec3(0., 0., 1.));
    d += DrawPoint(ro, rd, vec3(0., 1., 0.));
    d += DrawPoint(ro, rd, vec3(0., 1., 1.));
    d += DrawPoint(ro, rd, vec3(1., 0., 0.));
    d += DrawPoint(ro, rd, vec3(1., 0., 1.));
    d += DrawPoint(ro, rd, vec3(1., 1., 0.));
    d += DrawPoint(ro, rd, vec3(1., 1., 1.));
    
    
	outColor = vec4(d);
}
]]>
</program>
</language>
</jittershader>
