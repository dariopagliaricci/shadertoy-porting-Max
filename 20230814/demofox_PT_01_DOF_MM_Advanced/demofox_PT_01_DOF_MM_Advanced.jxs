<jittershader name="default">
	<description>Default Slab </description>

	<param name="MVP" type="mat4" state="MODELVIEW_PROJECTION_MATRIX" />
	
	<param name="pos" type="vec3" state="POSITION" />
	<param name="uv" type="vec2" state="TEXCOORD" />
	<param name="viewPort" type="vec2" state="VIEWPORT" />
	<param name="eye" type="vec3" state="CAMERA_POSITION" />
	<param name="sample" type="float" default="0.0" />

    <param name="envTex" type="int" default="0" />

	<language name="glsl" version="1.5">


		<bind param="MVP" program="vp" />

		<bind param="pos" program="vp" />
		<bind param="uv" program="vp" />
		<bind param="viewPort" program="fp" />
		<bind param="eye" program="fp" />
		<bind param="sample" program="fp" />

        <bind param="envTex" program="fp" />
	
		<program name="vp" type="vertex"  >
		<![CDATA[
			#version 330 core
			
			in vec3 pos;
			in vec2 uv;

			out jit_PerVertex {
				vec2 uv;//texcoord

			} jit_out;
			uniform mat4 MVP;
			uniform mat4 textureMatrix0;
			
			void main(void) {
				gl_Position = vec4(pos, 1.);//remove MVP matrix because using jit.gl.mesh
				jit_out.uv = uv;
			}
		]]>
		</program>
		
<program name="fp" type="fragment"  >
<![CDATA[
#version 330 core
#define BOUNCES 8
#define VERY_FAR 1e8
#define TWOPI 6.2831855

uniform vec2 viewPort;
uniform vec3 eye; 
uniform float sample; 
uniform samplerCube envTex;

struct rayInfo {
	vec3 origin;
	vec3 dir;
};

struct hitInfo {
	float t0;//dist in demofox struct SRayHitInfo
	vec3 nor;
};

struct matInfo {
	vec3 alb;
	vec3 emi;
};

struct searchInfo {
	float rngState; //search of an ontersection.Provide random values per pixels
	vec3 finalColor;
	vec3 through;
};

in jit_PerVertex {
vec2 uv;
} jit_in;

layout (location = 0) out vec4 outColor;

//
// Hash functions by Nimitz:
// https://www.shadertoy.com/view/Xt3cDn
// https://www.shadertoy.com/view/XlycWh
// Modified struct names
uint base_hash(uvec2 p) {
    p = 1103515245U*((p >> 1U)^(p.yx));
    uint h32 = 1103515245U*((p.x)^(p.y>>3U));
    return h32^(h32 >> 16);
}

float g_seed = 0.;

float hash1(inout searchInfo search) {
    uint n = base_hash(floatBitsToUint(vec2(search.rngState+=.1,search.rngState+=.1)));
    return float(n)/float(0xffffffffU);
}

vec2 hash2(inout searchInfo search) {
    uint n = base_hash(floatBitsToUint(vec2(search.rngState+=.1,search.rngState+=.1)));
    uvec2 rz = uvec2(n, n*48271U);
    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);
}

vec3 hash3(inout searchInfo search) {
    uint n = base_hash(floatBitsToUint(vec2(search.rngState+=.1,search.rngState+=.1)));
    uvec3 rz = uvec3(n, n*16807U, n*48271U);
    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);
}

//Reinder Nijhoff RIOW shadertoy
vec3 random_in_unit_sphere(inout searchInfo search) {
    vec3 h = hash3(search) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);
    float phi = h.y;
    float r = pow(h.z, 1./3.);
	return r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);
}

float ScalarTriple(vec3 u, vec3 v, vec3 w)
{
    return dot(cross(u, v), w);
}

void TestQuadTrace(inout rayInfo ray, inout hitInfo hit, inout matInfo mat, in vec3 a, in vec3 b, in vec3 c, in vec3 d, vec3 color, vec3 emissive)
{
    // calculate normal and flip vertices order if needed
    vec3 normal = normalize(cross(c-a, c-b));
    if (dot(normal, ray.dir) > 0.0f)
    {
        normal *= -1.0f;
        
		vec3 temp = d;
        d = a;
        a = temp;
        
        temp = b;
        b = c;
        c = temp;
    }
    
    vec3 p = ray.origin;
    vec3 q = ray.origin + ray.dir;
    vec3 pq = q - p;
    vec3 pa = a - p;
    vec3 pb = b - p;
    vec3 pc = c - p;
    
    // determine which triangle to test against by testing against diagonal first
    vec3 m = cross(pc, pq);
    float v = dot(pa, m);
    vec3 intersectPos;
    if (v >= 0.0f)
    {
        // test against triangle a,b,c
        float u = -dot(pb, m);
        if (u < 0.0f) return;
        float w = ScalarTriple(pq, pb, pa);
        if (w < 0.0f) return;
        float denom = 1.0f / (u+v+w);
        u*=denom;
        v*=denom;
        w*=denom;
        intersectPos = u*a+v*b+w*c;
    }
    else
    {
        vec3 pd = d - p;
        float u = dot(pd, m);
        if (u < 0.0f) return;
        float w = ScalarTriple(pq, pa, pd);
        if (w < 0.0f) return;
        v = -v;
        float denom = 1.0f / (u+v+w);
        u*=denom;
        v*=denom;
        w*=denom;
        intersectPos = u*a+v*d+w*c;
    }
    
    float dist;
    if (abs(ray.dir.x) > 0.1f)
    {
        dist = (intersectPos.x - ray.origin.x) / ray.dir.x;
    }
    else if (abs(ray.dir.y) > 0.1f)
    {
        dist = (intersectPos.y - ray.origin.y) / ray.dir.y;
    }
    else
    {
        dist = (intersectPos.z - ray.origin.z) / ray.dir.z;
    }
    
	if(dist < hit.t0) //(dist > c_minimumRayHitTime && dist < info.dist)
    {
        hit.t0 = dist;        
        hit.nor = normal;
        mat.alb = color;
        mat.emi = emissive;
        return;
    }    
    
    return;
}

// https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/
// https://www.shadertoy.com/view/tsBBWW. modified
//Rename struct components
//Change the function from bool to void, in order to call it from inside other function
void TestSphereTrace(in rayInfo ray, inout hitInfo hit, inout matInfo mat, in vec4 sphere, vec3 color, vec3 emissive)
{
	//get the vector from the center of this sphere to where the ray begins.
	vec3 m = ray.origin - sphere.xyz;

    //get the dot product of the above vector and the ray's vector
	float b = dot(m, ray.dir);

	float c = dot(m, m) - sphere.w * sphere.w;

	//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
	if(c > 0.0 && b > 0.0)
		return;

	//calculate discriminant
	float discr = b * b - c;

	//a negative discriminant corresponds to ray missing sphere
	if(discr < 0.0)
		return;
    
	//ray now found to intersect sphere, compute smallest t value of intersection
    bool fromInside = false;
	float dist = -b - sqrt(discr);
    if (dist < 0.0f)
    {
        fromInside = true;
        dist = -b + sqrt(discr);
    }
    
	if(dist < hit.t0)// if (dist > c_minimumRayHitTime && dist < hit.t0)
    {
        hit.t0 = dist;        
        hit.nor = normalize((ray.origin+ray.dir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);
        mat.alb = color;
        mat.emi = emissive;
        return;
    }
    
    return;
}

void TestSceneTrace(inout rayInfo ray, inout hitInfo hit, inout matInfo mat)
{    
    
   	// back wall
    {
        
        vec3 A = vec3(-12.6f, -12.6f, 25.0f);
        vec3 B = vec3( 12.6f, -12.6f, 25.0f);
        vec3 C = vec3( 12.6f,  12.6f, 25.0f);
        vec3 D = vec3(-12.6f,  12.6f, 25.0f);
        TestQuadTrace(ray, hit, mat, A, B, C, D, vec3(0.7f, 0.7f, 0.7f), vec3(0.0f, 0.0f, 0.0f));
        // {
        //     hitInfo.albedo = vec3(0.7f, 0.7f, 0.7f);
        //     hitInfo.emissive = vec3(0.0f, 0.0f, 0.0f);
        // }
   
	}    
    
    // floor
    {
        vec3 A = vec3(-12.6f, -12.45f, 25.0f);
        vec3 B = vec3( 12.6f, -12.45f, 25.0f);
        vec3 C = vec3( 12.6f, -12.45f, 15.0f);
        vec3 D = vec3(-12.6f, -12.45f, 15.0f);
        TestQuadTrace(ray, hit, mat, A, B, C, D, vec3(0.7f, 0.7f, 0.7f), vec3(0.0f, 0.0f, 0.0f));
        // {
        //     hitInfo.albedo = vec3(0.7f, 0.7f, 0.7f);
        //     hitInfo.emissive = vec3(0.0f, 0.0f, 0.0f);
        // }        
    }
    
    // cieling
    {
        vec3 A = vec3(-12.6f, 12.5f, 25.0f);
        vec3 B = vec3( 12.6f, 12.5f, 25.0f);
        vec3 C = vec3( 12.6f, 12.5f, 15.0f);
        vec3 D = vec3(-12.6f, 12.5f, 15.0f);
        TestQuadTrace(ray, hit, mat, A, B, C, D, vec3(0.7f, 0.7f, 0.7f),vec3(0.0f, 0.0f, 0.0f));
        // {
        //     hitInfo.albedo = vec3(0.7f, 0.7f, 0.7f);
        //     hitInfo.emissive = vec3(0.0f, 0.0f, 0.0f);
        // }        
    }    
    
    // left wall
    {
        vec3 A = vec3(-12.5f, -12.6f, 25.0f);
        vec3 B = vec3(-12.5f, -12.6f, 15.0f);
        vec3 C = vec3(-12.5f,  12.6f, 15.0f);
        vec3 D = vec3(-12.5f,  12.6f, 25.0f);
        TestQuadTrace(ray, hit, mat, A, B, C, D, vec3(0.7f, 0.1f, 0.1f), vec3(0.0f, 0.0f, 0.0f));
        // {
        //     hitInfo.albedo = vec3(0.7f, 0.1f, 0.1f);
        //     hitInfo.emissive = vec3(0.0f, 0.0f, 0.0f);
        // }        
    }
    
    // right wall 
    {
        vec3 A = vec3( 12.5f, -12.6f, 25.0f);
        vec3 B = vec3( 12.5f, -12.6f, 15.0f);
        vec3 C = vec3( 12.5f,  12.6f, 15.0f);
        vec3 D = vec3( 12.5f,  12.6f, 25.0f);
        TestQuadTrace(ray, hit, mat, A, B, C, D, vec3(0.1f, 0.7f, 0.1f), vec3(0.0f, 0.0f, 0.0f));
        // {
        //     hitInfo.albedo = vec3(0.1f, 0.7f, 0.1f);
        //     hitInfo.emissive = vec3(0.0f, 0.0f, 0.0f);
        // }        
    }    
    
    // light
    {
        vec3 A = vec3(-5.0f, 12.4f,  22.5f);
        vec3 B = vec3( 5.0f, 12.4f,  22.5f);
        vec3 C = vec3( 5.0f, 12.4f,  17.5f);
        vec3 D = vec3(-5.0f, 12.4f,  17.5f);
        TestQuadTrace(ray, hit, mat, A, B, C, D, vec3(0.0f, 0.0f, 0.0f), vec3(1.0f, 0.9f, 0.7f) * 20.0f);      
    }
    
	TestSphereTrace(ray, hit, mat, vec4(9.0f, -9.5f, 20.0f, 3.04), vec3(0.9f, 0.9f, 0.75f), vec3(0.0f, 0.0f, 0.0f));
    // {
    //     hitInfo.albedo = vec3(0.9f, 0.9f, 0.75f);
    //     hitInfo.emissive = vec3(0.0f, 0.0f, 0.0f);        
    // } 
    
	TestSphereTrace(ray, hit, mat, vec4(0.0f, -9.5f, 20.0f, 3.04), vec3(0.9f, 0.75f, 0.9f), vec3(0.0f, 0.0f, 0.0f));
    // {
    //     hitInfo.albedo = vec3(0.9f, 0.75f, 0.9f);
    //     hitInfo.emissive = vec3(0.0f, 0.0f, 0.0f);        
    // }    
    
	TestSphereTrace(ray, hit, mat,  vec4(-9.0f, -9.5f, 20.0f, 3.04), vec3(0.75f, 0.9f, 0.9f), vec3(0.0f, 0.0f, 0.0f)); 
    // {
    //     hitInfo.albedo = vec3(0.75f, 0.9f, 0.9f);
    //     hitInfo.emissive = vec3(0.0f, 0.0f, 0.0f);
    // }    
}

float planeIntersect(vec3 ro, vec3 rd, vec4 p){
    return -(dot(ro, p.xyz)+p.w)/dot(rd, p.xyz);
}


void computeFirstRay(out rayInfo ray, inout searchInfo search){
	vec2 screenPos = jit_in.uv *2.0 - 1.0;//demofox pixelTarget2D
	float ratio = viewPort.x / viewPort.y;//aspectRatio demofox
	screenPos.x *= ratio;//correct aspect ratio of horizontal axis of screen
	ray.origin = eye;// demofox rayPosition 

	//camera matrix
	vec3 target = vec3 (0.); // origin position
	vec3 front = normalize(target - ray.origin); //in front position
	vec3 right = cross(vec3(0., 1., 0.), front); //right pos
	vec3 up = cross(front, right); // up pos

	
	vec3 pixPos = vec3(screenPos, 4);//demoflox rayTarget. Modified (4 units in Z axis)
	// ray.dir = normalize(pixPos - ray.origin); // compute rayDir axis perfectly aligned
	ray.dir = normalize(pixPos.x*right + pixPos.y*up + pixPos.z*front);

	float focalDist = 0;
	float focalPlane = planeIntersect(ray.origin, ray.dir, vec4(-front, focalDist));
    vec3 focalPoint = ray.origin + ray.dir * focalPlane;

    float aperture = 0.3;
    float angle = hash1(search)*TWOPI;
    float radius = sqrt(hash1(search));
    vec2 cameraShift = radius*vec2(cos(angle), sin(angle))*aperture;
    float screenDist = planeIntersect(ray.origin, ray.dir, vec4(front, 4));
    ray.origin = eye +ray.dir*screenDist;
    ray.origin += right*cameraShift.x + up*cameraShift.y;
    ray.dir = normalize(focalPoint - ray.origin);
}

void rayTrace(in rayInfo ray, inout hitInfo hit, inout matInfo mat, inout searchInfo search){

	hit.t0 = VERY_FAR;
	TestSceneTrace(ray, hit, mat);
	// vec3 center0 = vec3(0., 0., 0.);
	// float radius0 = 0.2;
	// vec3 center1 = vec3(-0.5, 0., -3.5);
	// float radius1 = 0.3;

	// TestSphereTrace(ray, hit, mat, vec4(center0, radius0), vec3(1, 0, 0)); //call this function inside
	// TestSphereTrace(ray, hit, mat, vec4(center1, radius1), vec3(0, 1, 0)); 

	return; 
}

void miss(inout rayInfo ray, inout searchInfo search){
	// search.finalColor += vec3(0.) * search.through;
    search.finalColor += texture(envTex, ray.dir).rgb * search.through;

}

void updateColor(inout matInfo mat, inout searchInfo search){
	search.finalColor += mat.emi*search.through;
	search.through *= mat.alb;
}

void createNewRay(inout rayInfo ray, inout hitInfo hit, inout matInfo mat, inout searchInfo search){
	vec3 hitPos = ray.origin + ray.dir*hit.t0;
	ray.origin = hitPos;
	ray.origin += 0.0001*hit.nor;
	ray.dir = normalize(random_in_unit_sphere(search)+hit.nor); 
}

void getFragmentColor(inout rayInfo ray, inout hitInfo hit, inout matInfo mat, inout searchInfo search){
	
	search.through = vec3(1);
	search.finalColor = vec3(0.);
	for(int i = 0; i < BOUNCES; i++){
		rayTrace(ray, hit, mat, search);		
		if(hit.t0 == VERY_FAR){
			miss(ray, search); 
			return;
			} 
		updateColor(mat, search);
		createNewRay(ray, hit, mat, search);
	}
	return;

}

void initializeRngState(out searchInfo search){
	search.rngState = float(base_hash(floatBitsToUint(jit_in.uv)))/float(0xffffffffU)+sample;
}

void main(void) {
	rayInfo ray;// declare a struct in the main function
	hitInfo hit;
	matInfo mat;
	searchInfo search;

	initializeRngState(search);
	computeFirstRay(ray, search);//declare previous function in the main function
	getFragmentColor(ray, hit, mat, search);
	outColor.rgb = search.finalColor;
	outColor.a = 1; //zero if miss
	// outColor.rgb = vec3(hash1(search));
}
]]>
		</program>
	</language>
</jittershader>
