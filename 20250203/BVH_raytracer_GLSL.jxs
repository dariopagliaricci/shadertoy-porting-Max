// BVH Custom RayTracer Shader GLSL
// (HLSL original format) Sebastian Lague

// --- Settings and constants ---
const float PI = 3.1415;

// Raytracing Settings
uniform int MaxBounceCount;
uniform int NumRaysPerPixel;
uniform int Frame;

// Camera settings
uniform float DefocusStrength;
uniform float DivergeStrength;
uniform vec3 ViewParams;
uniform mat4 CamLocalToWorldMatrix;

// Sky settings
uniform int UseSky;
uniform vec3 SunColour;
uniform float SunFocus = 500.0;
uniform float SunIntensity = 10.0;

// Debug settings
uniform int visMode;
uniform float debugVisScale;

// --- Structures ---
struct Ray {
    vec3 origin;
    vec3 dir;
    vec3 invDir;
};

struct Triangle {
    vec3 posA, posB, posC;
    vec3 normA, normB, normC;
};

// Calculate the intersection of a ray with a triangle using Möller–Trumbore algorithm
// Thanks to https://stackoverflow.com/a/42752998
struct TriangleHitInfo {
    bool didHit;
    float dst;
    vec3 hitPoint;
    vec3 normal;
    int triIndex;
};

struct RayTracingMaterial {
    vec4 colour;
    vec4 emissionColour;
    vec4 specularColour;
    float emissionStrength;
    float smoothness;
    float specularProbability;
    int flag;
};

struct Model {
    int nodeOffset;
    int triOffset;
    mat4 worldToLocalMatrix;
    mat4 localToWorldMatrix;
    RayTracingMaterial material;
};

struct BVHNode {
    vec3 boundsMin;
    vec3 boundsMax;
    int startIndex;
    int triangleCount;
};

struct ModelHitInfo {
    bool didHit;
    vec3 normal;
    vec3 hitPoint;
    float dst;
    RayTracingMaterial material;
};

// --- Buffers (and their sizes) ---
layout(std430) buffer ModelBuffer {
    Model ModelInfo[];
};
layout(std430) buffer TriangleBuffer {
    Triangle Triangles[];
};
layout(std430) buffer BVHNodeBuffer {
    BVHNode Nodes[];
};
uniform int triangleCount;
uniform int modelCount;

// ---- RNG Functions ----

uint NextRandom(inout uint state) {
    state = state * 747796405u + 2891336453u;
    uint result = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    result = (result >> 22u) ^ result;
    return result;
}

float RandomValue(inout uint state) {
    return float(NextRandom(state)) / 4294967295.0; // 2^32 - 1
}

float RandomValueNormalDistribution(inout uint state) {
    float theta = 2.0 * PI * RandomValue(state);
    float rho = sqrt(-2.0 * log(RandomValue(state)));
    return rho * cos(theta);
}

vec3 RandomDirection(inout uint state) {
    float x = RandomValueNormalDistribution(state);
    float y = RandomValueNormalDistribution(state);
    float z = RandomValueNormalDistribution(state);
    return normalize(vec3(x, y, z));
}

vec2 RandomPointInCircle(inout uint rngState) {
    float angle = RandomValue(rngState) * 2.0 * PI;
    vec2 pointOnCircle = vec2(cos(angle), sin(angle));
    return pointOnCircle * sqrt(RandomValue(rngState));
}

vec3 GetEnvironmentLight(vec3 dir) {
    if (UseSky == 0) return vec3(0.0);
    const vec3 GroundColour = vec3(0.35, 0.3, 0.35);
    const vec3 SkyColourHorizon = vec3(1.0);
    const vec3 SkyColourZenith = vec3(0.08, 0.37, 0.73);

    float skyGradientT = pow(smoothstep(0.0, 0.4, dir.y), 0.35);
    float groundToSkyT = smoothstep(-0.01, 0.0, dir.y);
    vec3 skyGradient = mix(SkyColourHorizon, SkyColourZenith, skyGradientT);
    float sun = pow(max(0.0, dot(dir, normalize(vec3(0.0, 1.0, 0.0)))), SunFocus) * SunIntensity;
    vec3 composite = mix(GroundColour, skyGradient, groundToSkyT) + sun * SunColour * step(1.0, groundToSkyT);
    return composite;
}

// --- Ray Intersection Functions ---
bool IntersectTriangle(Ray ray, Triangle tri, out TriangleHitInfo hitInfo) {
    const float EPSILON = 0.0001;
    vec3 edge1 = tri.posB - tri.posA;
    vec3 edge2 = tri.posC - tri.posA;
    vec3 pvec = cross(ray.dir, edge2);
    float det = dot(edge1, pvec);

    if (abs(det) < EPSILON) return false;
    float invDet = 1.0 / det;

    vec3 tvec = ray.origin - tri.posA;
    float u = dot(tvec, pvec) * invDet;
    if (u < 0.0 || u > 1.0) return false;

    vec3 qvec = cross(tvec, edge1);
    float v = dot(ray.dir, qvec) * invDet;
    if (v < 0.0 || u + v > 1.0) return false;

    float t = dot(edge2, qvec) * invDet;
    if (t < EPSILON) return false;

    hitInfo.didHit = true;
    hitInfo.dst = t;
    hitInfo.hitPoint = ray.origin + t * ray.dir;
    hitInfo.normal = normalize(cross(edge1, edge2));
    return true;
}

// --- Shader main entry point ---
void main() {
    // Raytracing logic will go here
    // Compute intersections, shading, and output the final color
}


TriangleHitInfo RayTriangle(Ray ray, Triangle tri) {
    vec3 edgeAB = tri.posB - tri.posA;
    vec3 edgeAC = tri.posC - tri.posA;
    vec3 normalVector = cross(edgeAB, edgeAC);
    vec3 ao = ray.origin - tri.posA;
    vec3 dao = cross(ao, ray.dir);

    float determinant = -dot(ray.dir, normalVector);
    float invDet = 1.0 / determinant;

    float dst = dot(ao, normalVector) * invDet;
    float u = dot(edgeAC, dao) * invDet;
    float v = -dot(edgeAB, dao) * invDet;
    float w = 1.0 - u - v;

    TriangleHitInfo hitInfo;
    hitInfo.didHit = determinant >= 1e-8 && dst >= 0.0 && u >= 0.0 && v >= 0.0 && w >= 0.0;
    hitInfo.hitPoint = ray.origin + ray.dir * dst;
    hitInfo.normal = normalize(tri.normA * w + tri.normB * u + tri.normC * v);
    hitInfo.dst = dst;
    return hitInfo;
}

// Calculate the intersection distance of a ray with an axis-aligned bounding box
float RayBoundingBoxDst(Ray ray, vec3 boxMin, vec3 boxMax) {
    vec3 tMin = (boxMin - ray.origin) * ray.invDir;
    vec3 tMax = (boxMax - ray.origin) * ray.invDir;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);

    bool hit = tFar >= tNear && tFar > 0.0;
    return hit ? (tNear > 0.0 ? tNear : 0.0) : 1.0 / 0.0; // Use `1.0 / 0.0` for infinity in GLSL
}

// Traverse BVH and find closest triangle intersection
TriangleHitInfo RayTriangleBVH(inout Ray ray, float rayLength, int nodeOffset, int triOffset, inout ivec2 stats) {
    TriangleHitInfo result;
    result.dst = rayLength;
    result.triIndex = -1;

    int stack[32];
    int stackIndex = 0;
    stack[stackIndex++] = nodeOffset;

    while (stackIndex > 0) {
        BVHNode node = Nodes[stack[--stackIndex]];
        bool isLeaf = node.triangleCount > 0;

        if (isLeaf) {
            for (int i = 0; i < node.triangleCount; i++) {
                Triangle tri = Triangles[triOffset + node.startIndex + i];
                TriangleHitInfo triHitInfo = RayTriangle(ray, tri);
                stats.x++; // count triangle intersection tests

                if (triHitInfo.didHit && triHitInfo.dst < result.dst) {
                    result = triHitInfo;
                    result.triIndex = node.startIndex + i;
                }
            }
        } else {
            int childIndexA = nodeOffset + node.startIndex;
            int childIndexB = nodeOffset + node.startIndex + 1;

            BVHNode childA = Nodes[childIndexA];
            BVHNode childB = Nodes[childIndexB];

            float dstA = RayBoundingBoxDst(ray, childA.boundsMin, childA.boundsMax);
            float dstB = RayBoundingBoxDst(ray, childB.boundsMin, childB.boundsMax);
            stats.y += 2; // count bounding box intersection tests

            bool isNearestA = dstA <= dstB;
            float dstNear = isNearestA ? dstA : dstB;
            float dstFar = isNearestA ? dstB : dstA;
            int childIndexNear = isNearestA ? childIndexA : childIndexB;
            int childIndexFar = isNearestA ? childIndexB : childIndexA;

            if (dstFar < result.dst) stack[stackIndex++] = childIndexFar;
            if (dstNear < result.dst) stack[stackIndex++] = childIndexNear;
        }
    }

    return result;
}

// Calculate ray collision with models
ModelHitInfo CalculateRayCollision(Ray worldRay, out ivec2 stats) {
    ModelHitInfo result;
    result.dst = 1.0 / 0.0; // infinity in GLSL

    for (int i = 0; i < modelCount; i++) {
        Model model = ModelInfo[i];

        // Transform ray into model's local coordinate space
        Ray localRay;
        localRay.origin = (model.worldToLocalMatrix * vec4(worldRay.origin, 1.0)).xyz;
        localRay.dir = (model.worldToLocalMatrix * vec4(worldRay.dir, 0.0)).xyz;
        localRay.invDir = 1.0 / localRay.dir;

        // Traverse BVH to find closest triangle intersection with current model
        TriangleHitInfo hit = RayTriangleBVH(localRay, result.dst, model.nodeOffset, model.triOffset, stats);

        if (hit.dst < result.dst) {
            result.didHit = true;
            result.dst = hit.dst;
            result.normal = normalize((model.localToWorldMatrix * vec4(hit.normal, 0.0)).xyz);
            result.hitPoint = worldRay.origin + worldRay.dir * hit.dst;
            result.material = model.material;
        }
    }

    return result;
}

// --- Ray Intersection Functions ---

// Calculate the intersection of a ray with a triangle using Möller–Trumbore algorithm
// Thanks to https://stackoverflow.com/a/42752998
TriangleHitInfo RayTriangle(Ray ray, Triangle tri) {
    vec3 edgeAB = tri.posB - tri.posA;
    vec3 edgeAC = tri.posC - tri.posA;
    vec3 normalVector = cross(edgeAB, edgeAC);
    vec3 ao = ray.origin - tri.posA;
    vec3 dao = cross(ao, ray.dir);

    float determinant = -dot(ray.dir, normalVector);
    float invDet = 1.0 / determinant;

    // Calculate distance to triangle & barycentric coordinates of intersection point
    float dst = dot(ao, normalVector) * invDet;
    float u = dot(edgeAC, dao) * invDet;
    float v = -dot(edgeAB, dao) * invDet;
    float w = 1.0 - u - v;

    // Initialize hit info
    TriangleHitInfo hitInfo;
    hitInfo.didHit = determinant >= 1E-8 && dst >= 0.0 && u >= 0.0 && v >= 0.0 && w >= 0.0;
    hitInfo.hitPoint = ray.origin + ray.dir * dst;
    hitInfo.normal = normalize(tri.normA * w + tri.normB * u + tri.normC * v);
    hitInfo.dst = dst;
    return hitInfo;
}

// Thanks to https://tavianator.com/2011/ray_box.html
float RayBoundingBoxDst(Ray ray, vec3 boxMin, vec3 boxMax) {
    vec3 tMin = (boxMin - ray.origin) * ray.invDir;
    vec3 tMax = (boxMax - ray.origin) * ray.invDir;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);

    bool hit = tFar >= tNear && tFar > 0.0;
    float dst = hit ? (tNear > 0.0 ? tNear : 0.0) : 1.0 / 0.0;
    return dst;
}

TriangleHitInfo RayTriangleBVH(inout Ray ray, float rayLength, int nodeOffset, int triOffset, inout ivec2 stats) {
    TriangleHitInfo result;
    result.dst = rayLength;
    result.triIndex = -1;

    int stack[32];
    int stackIndex = 0;
    stack[stackIndex++] = nodeOffset;

    while (stackIndex > 0) {
        BVHNode node = Nodes[stack[--stackIndex]];
        bool isLeaf = node.triangleCount > 0;

        if (isLeaf) {
            for (int i = 0; i < node.triangleCount; i++) {
                Triangle tri = Triangles[triOffset + node.startIndex + i];
                TriangleHitInfo triHitInfo = RayTriangle(ray, tri);
                stats.x++; // count triangle intersection tests

                if (triHitInfo.didHit && triHitInfo.dst < result.dst) {
                    result = triHitInfo;
                    result.triIndex = node.startIndex + i;
                }
            }
        } else {
            int childIndexA = nodeOffset + node.startIndex;
            int childIndexB = nodeOffset + node.startIndex + 1;
            BVHNode childA = Nodes[childIndexA];
            BVHNode childB = Nodes[childIndexB];

            float dstA = RayBoundingBoxDst(ray, childA.boundsMin, childA.boundsMax);
            float dstB = RayBoundingBoxDst(ray, childB.boundsMin, childB.boundsMax);
            stats.y += 2; // count bounding box intersection tests

            // Look at closest child node first, so push it last
            bool isNearestA = dstA <= dstB;
            float dstNear = isNearestA ? dstA : dstB;
            float dstFar = isNearestA ? dstB : dstA;
            int childIndexNear = isNearestA ? childIndexA : childIndexB;
            int childIndexFar = isNearestA ? childIndexB : childIndexA;

            if (dstFar < result.dst) stack[stackIndex++] = childIndexFar;
            if (dstNear < result.dst) stack[stackIndex++] = childIndexNear;
        }
    }

    return result;
}

ModelHitInfo CalculateRayCollision(Ray worldRay, out ivec2 stats) {
    ModelHitInfo result;
    result.dst = 1.0 / 0.0;
    Ray localRay;

    for (int i = 0; i < modelCount; i++) {
        Model model = ModelInfo[i];
        // Transform ray into model's local coordinate space
        localRay.origin = (model.worldToLocalMatrix * vec4(worldRay.origin, 1.0)).xyz;
        localRay.dir = (model.worldToLocalMatrix * vec4(worldRay.dir, 0.0)).xyz;
        localRay.invDir = 1.0 / localRay.dir;

        // Traverse BVH to find closest triangle intersection with current model
        TriangleHitInfo hit = RayTriangleBVH(localRay, result.dst, model.nodeOffset, model.triOffset, stats);

        // Record closest hit
        if (hit.dst < result.dst) {
            result.didHit = true;
            result.dst = hit.dst;
            result.normal = normalize((model.localToWorldMatrix * vec4(hit.normal, 0.0)).xyz);
            result.hitPoint = worldRay.origin + worldRay.dir * hit.dst;
            result.material = model.material;
        }
    }

    return result;
}

vec3 Trace(vec3 rayOrigin, vec3 rayDir, inout uint rngState) {
    vec3 incomingLight = vec3(0.0);
    vec3 rayColour = vec3(1.0);

    ivec2 stats;
    float dstSum = 0.0;

    for (int bounceIndex = 0; bounceIndex <= MaxBounceCount; bounceIndex++) {
        Ray ray;
        ray.origin = rayOrigin;
        ray.dir = rayDir;
        ModelHitInfo hitInfo = CalculateRayCollision(ray, stats);

        if (hitInfo.didHit) {
            dstSum += hitInfo.dst;
            RayTracingMaterial material = hitInfo.material;

            if (material.flag == 1) { // Checker pattern
                vec2 c = mod(floor(hitInfo.hitPoint.xz), vec2(2.0));
                material.colour = c.x == c.y ? material.colour : material.emissionColour;
            }

            // New ray position and direction
            bool isSpecularBounce = material.specularProbability >= RandomValue(rngState);

            rayOrigin = hitInfo.hitPoint;
            vec3 diffuseDir = normalize(hitInfo.normal + RandomDirection(rngState));
            vec3 specularDir = reflect(rayDir, hitInfo.normal);
            rayDir = normalize(mix(diffuseDir, specularDir, material.smoothness * float(isSpecularBounce)));

            // Light calculations
            vec3 emittedLight = material.emissionColour * material.emissionStrength;
            incomingLight += emittedLight * rayColour;
            rayColour *= mix(material.colour, material.specularColour, float(isSpecularBounce));

            // Random early exit if ray colour is negligible
            float p = max(rayColour.r, max(rayColour.g, rayColour.b));
            if (RandomValue(rngState) >= p) {
                break;
            }
            rayColour /= p;
        } else {
            incomingLight += GetEnvironmentLight(rayDir) * rayColour;
            break;
        }
    }

    return incomingLight;
}


