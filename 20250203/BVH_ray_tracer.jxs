// BVH RayTracer Shader (HLSL original format) Sebastian Lague

// --- Settings and constants ---
const float PI = 3.1415;

// Raytracing Settings
int MaxBounceCount;
int NumRaysPerPixel;
int Frame;

// Camera settings
float DefocusStrength;
float DivergeStrength;
vec3 ViewParams;
//float4x4 CamLocalToWorldMatrix;
mat4 CamLocalToWorldMatrix;

// Sky settings
int UseSky;
vec3 SunColour;
float SunFocus = 500;
float SunIntensity = 10;

// Debug settings
int visMode;
float debugVisScale;

// --- Structures ---
struct Ray
{
	vec3 origin;
	vec3 dir;
	vec3 invDir;
};

struct Triangle
{
	vec3 posA, posB, posC;
	vec3 normA, normB, normC;
};

struct TriangleHitInfo
{
	bool didHit;
	float dst;
	vec3 hitPoint;
	vec3 normal;
	int triIndex;
};

struct RayTracingMaterial
{
	vec4 colour;
	vec4 emissionColour;
	vec4 specularColour;
	float emissionStrength;
	float smoothness;
	float specularProbability;
	int flag;
};

struct Model
{
	int nodeOffset;
	int triOffset;
	// float4x4 worldToLocalMatrix;
	// float4x4 localToWorldMatrix;
	mat4 worldToLocalMatrix;
	mat4 localToWorldMatrix;
	RayTracingMaterial material;
};

struct BVHNode
{
	vec3 boundsMin;
	vec3 boundsMax;
	// index refers to triangles if is leaf node (triangleCount > 0)
	// otherwise it is the index of the first child node
	int startIndex;
	int triangleCount;
};

struct ModelHitInfo
{
	bool didHit;
	vec3 normal;
	vec3 hitPoint;
	float dst;
	RayTracingMaterial material;
};

// --- Buffers (and their sizes) ---	
StructuredBuffer<Model> ModelInfo;
StructuredBuffer<Triangle> Triangles;
StructuredBuffer<BVHNode> Nodes;
int triangleCount;
int modelCount;

// ---- RNG Functions ----

// PCG (permuted congruential generator). Thanks to:
// www.pcg-random.org and www.shadertoy.com/view/XlGcRh
uint NextRandom(inout uint state)
{
	state = state * 747796405 + 2891336453;
	uint result = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
	result = (result >> 22) ^ result;
	return result;
}

float RandomValue(inout uint state)
{
	return NextRandom(state) / 4294967295.0; // 2^32 - 1
}

// Random value in normal distribution (with mean=0 and sd=1)
float RandomValueNormalDistribution(inout uint state)
{
	// Thanks to https://stackoverflow.com/a/6178290
	float theta = 2 * 3.1415926 * RandomValue(state);
	float rho = sqrt(-2 * log(RandomValue(state)));
	return rho * cos(theta);
}

// Calculate a random direction
vec3 RandomDirection(inout uint state)
{
	// Thanks to https://math.stackexchange.com/a/1585996
	float x = RandomValueNormalDistribution(state);
	float y = RandomValueNormalDistribution(state);
	float z = RandomValueNormalDistribution(state);
	return normalize(vec3(x, y, z));
}

vec2 RandomPointInCircle(inout uint rngState)
{
	float angle = RandomValue(rngState) * 2 * PI;
	vec2 pointOnCircle = vec2(cos(angle), sin(angle));
	return pointOnCircle * sqrt(RandomValue(rngState));
}

// Crude sky colour function for background light
vec3 GetEnvironmentLight(vec3 dir)
{
	if (UseSky == 0) return 0;
	const vec3 GroundColour = vec3(0.35, 0.3, 0.35);
	const vec3 SkyColourHorizon = vec3(1, 1, 1);
	const vec3 SkyColourZenith = vec3(0.08, 0.37, 0.73);
	

	float skyGradientT = pow(smoothstep(0, 0.4, dir.y), 0.35);
	float groundToSkyT = smoothstep(-0.01, 0, dir.y);
	vec3 skyGradient = lerp(SkyColourHorizon, SkyColourZenith, skyGradientT);
	float sun = pow(max(0, dot(dir, _WorldSpaceLightPos0.xyz)), SunFocus) * SunIntensity;
	// Combine ground, sky, and sun
	vec3 composite = lerp(GroundColour, skyGradient, groundToSkyT) + sun * SunColour * (groundToSkyT >= 1);
	return composite;
}

// --- Ray Intersection Functions ---

// Calculate the intersection of a ray with a triangle using M�ller�Trumbore algorithm
// Thanks to https://stackoverflow.com/a/42752998
TriangleHitInfo RayTriangle(Ray ray, Triangle tri)
{
	vec3 edgeAB = tri.posB - tri.posA;
	vec3 edgeAC = tri.posC - tri.posA;
	vec3 normalVector = cross(edgeAB, edgeAC);
	vec3 ao = ray.origin - tri.posA;
	vec3 dao = cross(ao, ray.dir);

	float determinant = -dot(ray.dir, normalVector);
	float invDet = 1 / determinant;

	// Calculate dst to triangle & barycentric coordinates of intersection point
	float dst = dot(ao, normalVector) * invDet;
	float u = dot(edgeAC, dao) * invDet;
	float v = -dot(edgeAB, dao) * invDet;
	float w = 1 - u - v;

	// Initialize hit info
	TriangleHitInfo hitInfo;
	hitInfo.didHit = determinant >= 1E-8 && dst >= 0 && u >= 0 && v >= 0 && w >= 0;
	hitInfo.hitPoint = ray.origin + ray.dir * dst;
	hitInfo.normal = normalize(tri.normA * w + tri.normB * u + tri.normC * v);
	hitInfo.dst = dst;
	return hitInfo;
}

// Thanks to https://tavianator.com/2011/ray_box.html
float RayBoundingBoxDst(Ray ray, vec3 boxMin, vec3 boxMax)
{
	vec3 tMin = (boxMin - ray.origin) * ray.invDir;
	vec3 tMax = (boxMax - ray.origin) * ray.invDir;
	vec3 t1 = min(tMin, tMax);
	vec3 t2 = max(tMin, tMax);
	float tNear = max(max(t1.x, t1.y), t1.z);
	float tFar = min(min(t2.x, t2.y), t2.z);

	bool hit = tFar >= tNear && tFar > 0;
	float dst = hit ? tNear > 0 ? tNear : 0 : 1.#INF;
	return dst;
};


TriangleHitInfo RayTriangleBVH(inout Ray ray, float rayLength, int nodeOffset, int triOffset, inout int2 stats)
{
	TriangleHitInfo result;
	result.dst = rayLength;
	result.triIndex = -1;

	int stack[32];
	int stackIndex = 0;
	stack[stackIndex++] = nodeOffset + 0;

	while (stackIndex > 0)
	{
		BVHNode node = Nodes[stack[--stackIndex]];
		bool isLeaf = node.triangleCount > 0;

		if (isLeaf)
		{
			for (int i = 0; i < node.triangleCount; i++)
			{
				Triangle tri = Triangles[triOffset + node.startIndex + i];
				TriangleHitInfo triHitInfo = RayTriangle(ray, tri);
				stats[0]++; // count triangle intersection tests

				if (triHitInfo.didHit && triHitInfo.dst < result.dst)
				{
					result = triHitInfo;
					result.triIndex = node.startIndex + i;
				}
			}
		}
		else
		{
			int childIndexA = nodeOffset + node.startIndex + 0;
			int childIndexB = nodeOffset + node.startIndex + 1;
			BVHNode childA = Nodes[childIndexA];
			BVHNode childB = Nodes[childIndexB];

			float dstA = RayBoundingBoxDst(ray, childA.boundsMin, childA.boundsMax);
			float dstB = RayBoundingBoxDst(ray, childB.boundsMin, childB.boundsMax);
			stats[1] += 2; // count bounding box intersection tests
			
			// We want to look at closest child node first, so push it last
			bool isNearestA = dstA <= dstB;
			float dstNear = isNearestA ? dstA : dstB;
			float dstFar = isNearestA ? dstB : dstA;
			int childIndexNear = isNearestA ? childIndexA : childIndexB;
			int childIndexFar = isNearestA ? childIndexB : childIndexA;

			if (dstFar < result.dst) stack[stackIndex++] = childIndexFar;
			if (dstNear < result.dst) stack[stackIndex++] = childIndexNear;
		}
	}


	return result;
}

ModelHitInfo CalculateRayCollision(Ray worldRay, out int2 stats)
{
	ModelHitInfo result;
	result.dst = 1.#INF;
	Ray localRay;

	for (int i = 0; i < modelCount; i++)
	{
		Model model = ModelInfo[i];
		// Transform ray into model's local coordinate space
		localRay.origin = mul(model.worldToLocalMatrix, float4(worldRay.origin, 1));
		localRay.dir = mul(model.worldToLocalMatrix, float4(worldRay.dir, 0));
		localRay.invDir = 1 / localRay.dir;

		// Traverse bvh to find closest triangle intersection with current model
		TriangleHitInfo hit = RayTriangleBVH(localRay, result.dst, model.nodeOffset, model.triOffset, stats);

		// Record closest hit
		if (hit.dst < result.dst)
		{
			result.didHit = true;
			result.dst = hit.dst;
			result.normal = normalize(mul(model.localToWorldMatrix, float4(hit.normal, 0)));
			result.hitPoint = worldRay.origin + worldRay.dir * hit.dst;
			result.material = model.material;
		}
	}

	return result;
}

vec2 mod2(vec2 x, vec2 y)
{
	return x - y * floor(x / y);
}

vec3 Trace(vec3 rayOrigin, vec3 rayDir, inout uint rngState)
{
	vec3 incomingLight = 0;
	vec3 rayColour = 1;
	
	int2 stats;
	float dstSum = 0;

	for (int bounceIndex = 0; bounceIndex <= MaxBounceCount; bounceIndex++)
	{
		Ray ray;
		ray.origin = rayOrigin;
		ray.dir = rayDir;
		ModelHitInfo hitInfo = CalculateRayCollision(ray, stats);

		if (hitInfo.didHit)
		{
			dstSum += hitInfo.dst;
			RayTracingMaterial material = hitInfo.material;
			if (material.flag == 1) // Checker pattern
			{
				vec2 c = mod2(floor(hitInfo.hitPoint.xz), 2.0);
				material.colour = c.x == c.y ? material.colour : material.emissionColour;
			}

			// Figure out new ray position and direction
			bool isSpecularBounce = material.specularProbability >= RandomValue(rngState);

			rayOrigin = hitInfo.hitPoint;
			vec3 diffuseDir = normalize(hitInfo.normal + RandomDirection(rngState));
			vec3 specularDir = reflect(rayDir, hitInfo.normal);
			rayDir = normalize(lerp(diffuseDir, specularDir, material.smoothness * isSpecularBounce));

			// Update light calculations
			vec3 emittedLight = material.emissionColour * material.emissionStrength;
			incomingLight += emittedLight * rayColour;
			rayColour *= lerp(material.colour, material.specularColour, isSpecularBounce);

			// Random early exit if ray colour is nearly 0 (can't contribute much to final result)
			float p = max(rayColour.r, max(rayColour.g, rayColour.b));
			if (RandomValue(rngState) >= p) {
				break;
			}
			rayColour *= 1.0f / p;
		}
		else
		{
			incomingLight += GetEnvironmentLight(rayDir) * rayColour;
			break;
		}
	}

	return incomingLight;
}


vec3 TraceDebugMode(vec3 rayOrigin, vec3 rayDir)
{
	int2 stats; // num triangle tests, num bounding box tests
	Ray ray;
	ray.origin = rayOrigin;
	ray.dir = rayDir;
	ModelHitInfo hitInfo = CalculateRayCollision(ray, stats);

	// Triangle test count vis
	if (visMode == 1)
	{
		float triVis = stats[0] / debugVisScale;
		return triVis < 1 ? triVis : vec3(1, 0, 0);
	}
	// Box test count vis
	else if (visMode == 2)//
	{
		float boxVis = stats[1] / debugVisScale;
		return boxVis < 1 ? boxVis : vec3(1, 0, 0);
	}
	// Distance
	else if (visMode == 3)
	{
		return length(rayOrigin - hitInfo.hitPoint) / debugVisScale;
	}
	// Normal
	else if (visMode == 4)
	{
		if (!hitInfo.didHit) return 0;
		return hitInfo.normal * 0.5 + 0.5;
	}

	return vec3(1, 0, 1); // Invalid test mode
}


// Run for every pixel in the display
vec4 frag(v2f i) : SV_Target
{
	// Create seed for random number generator
	uint2 numPixels = _ScreenParams.xy;
	uint2 pixelCoord = i.uv * numPixels;
	uint pixelIndex = pixelCoord.y * numPixels.x + pixelCoord.x;
	uint rngState = pixelIndex + Frame * 719393;//

	// Calculate focus point
	vec3 focusPointLocal = vec3(i.uv - 0.5, 1) * ViewParams;
	vec3 focusPoint = mul(CamLocalToWorldMatrix, vec4(focusPointLocal, 1));
	vec3 camRight = CamLocalToWorldMatrix._m00_m10_m20;
	vec3 camUp = CamLocalToWorldMatrix._m01_m11_m21;

	// Debug Mode
	#if DEBUG_VIS
		return vec4(TraceDebugMode(_WorldSpaceCameraPos, normalize(focusPoint - _WorldSpaceCameraPos)), 1);
	#endif
	
	// Trace multiple rays and average together
	vec3 totalIncomingLight = 0;

	for (int rayIndex = 0; rayIndex < NumRaysPerPixel; rayIndex++)
	{
		// -- Calculate ray origin and direction --
		// Jitter the starting point of the ray. This allows for a depth of field effect.
		vec2 defocusJitter = RandomPointInCircle(rngState) * DefocusStrength / numPixels.x;
		vec3 rayOrigin = _WorldSpaceCameraPos + camRight * defocusJitter.x + camUp * defocusJitter.y;

		// Jitter the focus point when calculating the ray direction to allow for blurring the image
		// (at low strengths, this can be used for anti-aliasing)
		vec2 jitter = RandomPointInCircle(rngState) * DivergeStrength / numPixels.x;
		vec3 jitteredFocusPoint = focusPoint + camRight * jitter.x + camUp * jitter.y;
		vec3 rayDir = normalize(jitteredFocusPoint - rayOrigin);

		// Trace
		totalIncomingLight += Trace(rayOrigin, rayDir, rngState);
	}


	vec3 pixelCol = totalIncomingLight / NumRaysPerPixel;
	return vec4(pixelCol, 1);
}

