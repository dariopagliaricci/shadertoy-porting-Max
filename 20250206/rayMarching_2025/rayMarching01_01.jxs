<jittershader name="default">
	<description>Default Slab </description>
	<param name="MVP" type="mat4" state="MODELVIEW_PROJECTION_MATRIX" />
	<param name="pos" type="vec3" state="POSITION" />
	<param name="uv" type="vec2" state="TEXCOORD" />

	<param name="viewPort" type="vec2" state="VIEWPORT" />
	<param name="spherePos" type="int" default="0" />
	<param name="lightPos" type="vec3" default="0.1 3. -5" />

	<language name="glsl" version="1.5">
		<bind param="MVP" program="vp" />
		<bind param="pos" program="vp" />
		<bind param="uv" program="vp" />

		<bind param="viewPort" program="fp" />
		<bind param="spherePos" program="fp" />
		<bind param="lightPos" program="fp" />

		<program name="vp" type="vertex"  >
		<![CDATA[
			#version 330 core
			
			in vec3 pos;
			in vec2 uv;
			out jit_PerVertex {
				vec2 uv;
			} jit_out;
			uniform mat4 MVP;
			
			void main(void) {
				gl_Position = MVP*vec4(pos, 1.);
				jit_out.uv = uv;
			}
		]]>
		</program>
		
<program name="fp" type="fragment"  >
<![CDATA[
#version 330 core
#define MAX_STEPS 100
#define MIN_DIST 0.0001
#define MAX_DIST 100.

in jit_PerVertex {
	vec2 uv;
} jit_in;
layout (location = 0) out vec4 outColor;

uniform vec2 viewPort;
uniform vec3 lightPos;
uniform sampler2DRect spherePos;

float SDFsphere(vec3 pos, vec3 c, float ra){
	return length(pos - c) - ra;
}

float getDist(vec3 pos){

	float closest = 100000;
	float dist;
	vec3 c;
	for(int i = 0; i < 10; i++){
		vec3 c = texture(spherePos, vec2(i, 0)).rgb;
		float dist = SDFsphere(pos, c, 0.1);
		closest = min(closest, dist);
	}
	return closest;
}

float map(vec3 ro, vec3 rd){
	float dist = 0;
	vec3 pos;
	for(int i = 0; i < MAX_STEPS; i++){
		pos = ro + rd * dist;
		dist += getDist(pos);
		if (dist < MIN_DIST || dist > MAX_DIST){
			break;
		}
	} 
	return dist;
}

vec3 getNorm(vec3 hitPos) {
	vec2 eps = vec2(0.00001, 0.);
	float shiftX = getDist(hitPos + eps.xyy) - getDist(hitPos - eps.xyy);
	float shiftY = getDist(hitPos + eps.yxy) - getDist(hitPos - eps.xyy);
	float shiftZ = getDist(hitPos + eps.yyx) - getDist(hitPos - eps.xyy);

	return normalize(vec3(shiftX, shiftY, shiftZ));
}

vec3 getLight(vec3 hitPos, vec3 rd) {
	vec3 normals = getNorm(hitPos);
	vec3 lightDir = normalize(hitPos - lightPos);
	float direct = max(-dot(lightDir, normals), 0.);
	vec3 refRd = reflect(rd, normals);
	float reflected = max(-dot(lightDir, refRd), 0.);
	reflected = pow(reflected, 100.);
	vec3 ambient = vec3(0.1);
	vec3 col = vec3(direct + reflected) + ambient;
	return col;
}

void main(void) {

	vec2 screenPos = jit_in.uv * 2 - 1;
	float ratio = viewPort.x / viewPort.y;
	screenPos.x *= ratio;

	vec3 ro = vec3(0., 0., -1);

	float planeDist = 0.6;
	vec3 rd = normalize(vec3(screenPos, planeDist));

	float dist = map(ro, rd);

	vec3 col = vec3(1., 0., 0.);
	vec3 bgCol = vec3(0.);

	if (dist > MAX_DIST){
		outColor = vec4(bgCol, 1.);
	} else {
		vec3 hitPos = ro + rd * dist;
		// vec3 normals = getNorm(hitPos);
		vec3 test = getLight(hitPos, rd);
		outColor = vec4(test, 1);
	}
}
]]>
</program>
</language>
</jittershader>
