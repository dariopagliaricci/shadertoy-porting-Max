<jittershader name="default">
	<description>Default Slab </description>

	<param name="MVP" type="mat4" state="MODELVIEW_PROJECTION_MATRIX" />
	<param name="pos" type="vec3" state="POSITION" />
	<param name="uv" type="vec2" state="TEXCOORD" />
	<param name="viewPort" type="vec2" state="VIEWPORT" />
	<param name="eye" type="vec3" state="CAMERA_POSITION" />

	<language name="glsl" version="1.5">

		<bind param="MVP" program="vp" />

		<bind param="pos" program="vp" />
		<bind param="uv" program="vp" />
		<bind param="viewPort" program="fp" />
		<bind param="eye" program="fp" />

		<program name="vp" type="vertex"  >
		<![CDATA[
			#version 330 core
			
			in vec3 pos;
			in vec2 uv;

			out jit_PerVertex {
				vec2 uv;
			} jit_out;
			uniform mat4 MVP;

			
			void main(void) {
				gl_Position = MVP*vec4(pos, 1.);
				jit_out.uv = uv;
			}
		]]>
		</program>
		
		<program name="fp" type="fragment"  >
		<![CDATA[
#version 330 core
	
in jit_PerVertex {
	vec2 uv;
} jit_in;

layout (location = 0) out vec4 outColor;

// The minimunm distance a ray must travel before we consider an intersection.
// This is to prevent a ray from intersecting a surface it just bounced off of.
const float c_minimumRayHitTime = 0.1f;
 
// the farthest we look for ray hits
const float c_superFar = 10000.0f;


uniform vec2 viewPort;
uniform vec3 eye;

struct rayInfo{
	vec3 origin;
	vec3 dir;
};

struct hitInfo{
	float dist;
	vec3 normal;
};

float ScalarTriple(vec3 u, vec3 v, vec3 w)
{
    return dot(cross(u, v), w);
}

bool TestQuadTrace(inout rayInfo ray, inout hitInfo hit, in vec3 a, in vec3 b, in vec3 c, in vec3 d)
{
    // calculate normal and flip vertices order if needed
    vec3 normal = normalize(cross(c-a, c-b));
    if (dot(normal, ray.dir) > 0.0f)
    {
        normal *= -1.0f;
        
		vec3 temp = d;
        d = a;
        a = temp;
        
        temp = b;
        b = c;
        c = temp;
    }
    
    vec3 p = ray.origin;
    vec3 q = ray.origin + ray.dir;
    vec3 pq = q - p;
    vec3 pa = a - p;
    vec3 pb = b - p;
    vec3 pc = c - p;
    
    // determine which triangle to test against by testing against diagonal first
    vec3 m = cross(pc, pq);
    float v = dot(pa, m);
    vec3 intersectPos;
    if (v >= 0.0f)
    {
        // test against triangle a,b,c
        float u = -dot(pb, m);
        if (u < 0.0f) return false;
        float w = ScalarTriple(pq, pb, pa);
        if (w < 0.0f) return false;
        float denom = 1.0f / (u+v+w);
        u*=denom;
        v*=denom;
        w*=denom;
        intersectPos = u*a+v*b+w*c;
    }
    else
    {
        vec3 pd = d - p;
        float u = dot(pd, m);
        if (u < 0.0f) return false;
        float w = ScalarTriple(pq, pa, pd);
        if (w < 0.0f) return false;
        v = -v;
        float denom = 1.0f / (u+v+w);
        u*=denom;
        v*=denom;
        w*=denom;
        intersectPos = u*a+v*d+w*c;
    }
    
    float dist;
    if (abs(ray.dir.x) > 0.1f)
    {
        dist = (intersectPos.x - ray.origin.x) / ray.dir.x;
    }
    else if (abs(ray.dir.y) > 0.1f)
    {
        dist = (intersectPos.y - ray.origin.y) / ray.dir.y;
    }
    else
    {
        dist = (intersectPos.z - ray.origin.z) / ray.dir.z;
    }
    
	if (dist > c_minimumRayHitTime && dist < hit.dist)
    {
        hit.dist = dist;        
        hit.normal = normal;        
        return true;
    }    
    
    return false;
}

bool TestSphereTrace(inout rayInfo ray, inout hitInfo hit, in vec4 sphere)
{
	//get the vector from the center of this sphere to where the ray begins.
	vec3 m = ray.origin - sphere.xyz;

    //get the dot product of the above vector and the ray's vector
	float b = dot(m, ray.dir);

	float c = dot(m, m) - sphere.w * sphere.w;

	//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
	if(c > 0.0 && b > 0.0)
		return false;

	//calculate discriminant
	float discr = b * b - c;

	//a negative discriminant corresponds to ray missing sphere
	if(discr < 0.0)
		return false;
    
	//ray now found to intersect sphere, compute smallest t value of intersection
    bool fromInside = false;
	float dist = -b - sqrt(discr);
    if (dist < 0.0f)
    {
        fromInside = true;
        dist = -b + sqrt(discr);
    }
    
	if (dist > c_minimumRayHitTime && dist < hit.dist)
    {
        hit.dist = dist;        
        hit.normal = normalize((ray.origin+ray.dir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);
        return true;
    }
    
    return false;
}

vec3 GetColorForRay(in rayInfo ray, inout hitInfo hit)
{
    hit.dist = c_superFar;
     
    vec3 ret = vec3(0.0f, 0.0f, 0.0f);
     
    if (TestSphereTrace(ray, hit, vec4(-10.0f, 0.0f, 20.0f, 1.0f)))
    {
        ret = vec3(1.0f, 0.1f, 0.1f);
    } 
     
    if (TestSphereTrace(ray, hit, vec4(0.0f, 0.0f, 20.0f, 1.0f)))
    {
        ret = vec3(0.1f, 1.0f, 0.1f);
    }    
     
    {
        vec3 A = vec3(-15.0f, -15.0f, 22.0f);
        vec3 B = vec3( 15.0f, -15.0f, 22.0f);
        vec3 C = vec3( 15.0f,  15.0f, 22.0f);
        vec3 D = vec3(-15.0f,  15.0f, 22.0f);
        if (TestQuadTrace(ray, hit, A, B, C, D))
        {
            ret = vec3(0.7f, 0.7f, 0.7f);
        }
    }
     
    if (TestSphereTrace(ray, hit, vec4(10.0f, 0.0f, 20.0f, 1.0f)))
    {
        ret = vec3(0.1f, 0.1f, 1.0f);
    }       
     
    return ret;
}


void main(void) {
	
	rayInfo ray;
	hitInfo hit;

	vec2 screenPos = jit_in.uv*2-1;
	float aspectRatio = viewPort.x / viewPort.y;
	screenPos.x *= aspectRatio; //corrrect x axis -1.777 to 1,777

	ray.origin = eye;
	vec3 pixPos = vec3(screenPos, 4);
	ray.dir = normalize(pixPos - ray.origin);

	vec3 color = GetColorForRay(ray, hit);

	outColor = vec4(color, 1);
}
]]>
</program>
</language>
</jittershader>
