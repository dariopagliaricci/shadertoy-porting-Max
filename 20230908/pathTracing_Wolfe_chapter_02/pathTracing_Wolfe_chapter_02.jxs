<jittershader name="default">
	<description>Default Slab </description>

	<param name="MVP" type="mat4" state="MODELVIEW_PROJECTION_MATRIX" />
	<param name="pos" type="vec3" state="POSITION" />
	<param name="uv" type="vec2" state="TEXCOORD" />
	<param name="viewPort" type="vec2" state="VIEWPORT" />
	<param name="eye" type="vec3" state="CAMERA_POSITION" />
    <param name="sample" type="float" default="0.0" />
    <param name="iMouse" type="vec3" default="0.0 0.0 0.0" />

    <param name="envTex" type="int" default="0" />
    <param name="iFrame" type="int" default="1" />

	<language name="glsl" version="1.5">

		<bind param="MVP" program="vp" />

		<bind param="pos" program="vp" />
		<bind param="uv" program="vp" />
		<bind param="viewPort" program="fp" />
		<bind param="eye" program="fp" />
        <bind param="sample" program="fp" />
        <bind param="iFrame" program="fp" />
        <bind param="iMouse" program="fp" />
        <bind param="envTex" program="fp" />

		<program name="vp" type="vertex"  >
		<![CDATA[
			#version 330 core
			
			in vec3 pos;
			in vec2 uv;

			out jit_PerVertex {
				vec2 uv;
			} jit_out;
			uniform mat4 MVP;

			
			void main(void) {
				gl_Position = vec4(pos, 1.);
				jit_out.uv = uv;
			}
		]]>
		</program>
		
		<program name="fp" type="fragment"  >
		<![CDATA[
#version 330 core
	
in jit_PerVertex {
	vec2 uv;
} jit_in;

layout (location = 0) out vec4 outColor;

// The minimunm distance a ray must travel before we consider an intersection.
// This is to prevent a ray from intersecting a surface it just bounced off of.
const float c_minimumRayHitTime = 0.1f;

// after a hit, it moves the ray this far along the normal away from a surface.
// Helps prevent incorrect intersections when rays bounce off of objects.
const float c_rayPosNormalNudge = 0.01f;
 
// the farthest we look for ray hits
const float c_superFar = 10000.0f;

// number of ray bounces allowed
const int c_numBounces = 8;

// camera FOV
const float c_FOVDegrees = 90.0f;

// a multiplier for the skybox brightness
const float c_skyboxBrightnessMultiplier = 1.0f;
    
// a pixel value multiplier of light before tone mapping and sRGB
const float c_exposure = 0.5f; 

// how many renders per frame - make this larger to get around the vsync limitation, and get a better image faster.
const int c_numRendersPerFrame = 8;

const float c_pi = 3.14159265359f;
const float c_twopi = 2.0f * c_pi;

// mouse camera control parameters
const float c_minCameraAngle = 0.01f;
const float c_maxCameraAngle = (c_pi - 0.01f);
const vec3 c_cameraAt = vec3(0.0f, 0.0f, 0.0f);
const float c_cameraDistance = 30.0f;

uniform vec2 viewPort;
uniform vec3 eye;
uniform float sample;
uniform vec3 iMouse;
uniform samplerCube envTex;
uniform int iFrame;

struct SMaterialInfo
{
    vec3 albedo;           // the color used for diffuse lighting
    vec3 emissive;         // how much the surface glows
    float percentSpecular; // percentage chance of doing specular instead of diffuse lighting
    float roughness;       // how rough the specular reflections are
    vec3 specularColor;    // the color tint of specular reflections
};

struct hitInfo{
	float dist;
	vec3 normal;
    SMaterialInfo material;
};

struct searchInfo {
    float rngState;
    // vec3 finalColor;
    // vec3 through;
};

vec3 LessThan(vec3 f, float value)
{
    return vec3(
        (f.x < value) ? 1.0f : 0.0f,
        (f.y < value) ? 1.0f : 0.0f,
        (f.z < value) ? 1.0f : 0.0f);
}
 
vec3 LinearToSRGB(vec3 rgb)
{
    rgb = clamp(rgb, 0.0f, 1.0f);
     
    return mix(
        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,
        rgb * 12.92f,
        LessThan(rgb, 0.0031308f)
    );
}
 
vec3 SRGBToLinear(vec3 rgb)
{
    rgb = clamp(rgb, 0.0f, 1.0f);
     
    return mix(
        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),
        rgb / 12.92f,
        LessThan(rgb, 0.04045f)
    );
}

// ACES tone mapping curve fit to go from HDR to LDR
//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
vec3 ACESFilm(vec3 x)
{
    float a = 2.51f;
    float b = 0.03f;
    float c = 2.43f;
    float d = 0.59f;
    float e = 0.14f;
    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);
}

uint base_hash(uvec2 p) {
    p = 1103515245U*((p >> 1U)^(p.yx));
    uint h32 = 1103515245U*((p.x)^(p.y>>3U));
    return h32^(h32 >> 16);
}

float g_seed = 0.;

float hash1(inout searchInfo search) {
    uint n = base_hash(floatBitsToUint(vec2(search.rngState+=.1,search.rngState+=.1)));
    return float(n)/float(0xffffffffU);
}

vec2 hash2(inout searchInfo search) {
    uint n = base_hash(floatBitsToUint(vec2(search.rngState+=.1,search.rngState+=.1)));
    uvec2 rz = uvec2(n, n*48271U);
    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);
}

vec3 hash3(inout searchInfo search) {
    uint n = base_hash(floatBitsToUint(vec2(search.rngState+=.1,search.rngState+=.1)));
    uvec3 rz = uvec3(n, n*16807U, n*48271U);
    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);
}

vec3 random_in_unit_sphere(inout searchInfo search) {
    vec3 h = hash3(search) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);
    float phi = h.y;
    float r = pow(h.z, 1./3.);
    return r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);
}

// uint wang_hash(inout uint seed)
// {
//     seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));
//     seed *= uint(9);
//     seed = seed ^ (seed >> 4);
//     seed *= uint(0x27d4eb2d);
//     seed = seed ^ (seed >> 15);
//     return seed;
// }

// float RandomFloat01(inout uint state)
// {
//     return float(wang_hash(state)) / 4294967296.0;
// }

// vec3 RandomUnitVector(inout uint state)
// {
//     float z = RandomFloat01(state) * 2.0f - 1.0f;
//     float a = RandomFloat01(state) * c_twopi;
//     float r = sqrt(1.0f - z * z);
//     float x = r * cos(a);
//     float y = r * sin(a);
//     return vec3(x, y, z);
// }



float ScalarTriple(vec3 u, vec3 v, vec3 w)
{
    return dot(cross(u, v), w);
}

bool TestQuadTrace(in vec3 rayPos, in vec3 rayDir, inout hitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d)
{
    // calculate normal and flip vertices order if needed
    vec3 normal = normalize(cross(c-a, c-b));
    if (dot(normal, rayDir) > 0.0f)
    {
        normal *= -1.0f;
        
        vec3 temp = d;
        d = a;
        a = temp;
        
        temp = b;
        b = c;
        c = temp;
    }
    
    vec3 p = rayPos;
    vec3 q = rayPos + rayDir;
    vec3 pq = q - p;
    vec3 pa = a - p;
    vec3 pb = b - p;
    vec3 pc = c - p;
    
    // determine which triangle to test against by testing against diagonal first
    vec3 m = cross(pc, pq);
    float v = dot(pa, m);
    vec3 intersectPos;
    if (v >= 0.0f)
    {
        // test against triangle a,b,c
        float u = -dot(pb, m);
        if (u < 0.0f) return false;
        float w = ScalarTriple(pq, pb, pa);
        if (w < 0.0f) return false;
        float denom = 1.0f / (u+v+w);
        u*=denom;
        v*=denom;
        w*=denom;
        intersectPos = u*a+v*b+w*c;
    }
    else
    {
        vec3 pd = d - p;
        float u = dot(pd, m);
        if (u < 0.0f) return false;
        float w = ScalarTriple(pq, pa, pd);
        if (w < 0.0f) return false;
        v = -v;
        float denom = 1.0f / (u+v+w);
        u*=denom;
        v*=denom;
        w*=denom;
        intersectPos = u*a+v*d+w*c;
    }
    
    float dist;
    if (abs(rayDir.x) > 0.1f)
    {
        dist = (intersectPos.x - rayPos.x) / rayDir.x;
    }
    else if (abs(rayDir.y) > 0.1f)
    {
        dist = (intersectPos.y - rayPos.y) / rayDir.y;
    }
    else
    {
        dist = (intersectPos.z - rayPos.z) / rayDir.z;
    }
    
    if (dist > c_minimumRayHitTime && dist < info.dist)
    {
        info.dist = dist;        
        info.normal = normal;        
        return true;
    }    
    
    return false;
}

bool TestSphereTrace(in vec3 rayPos, in vec3 rayDir, inout hitInfo info, in vec4 sphere)
{
    //get the vector from the center of this sphere to where the ray begins.
    vec3 m = rayPos - sphere.xyz;

    //get the dot product of the above vector and the ray's vector
    float b = dot(m, rayDir);

    float c = dot(m, m) - sphere.w * sphere.w;

    //exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
    if(c > 0.0 && b > 0.0)
        return false;

    //calculate discriminant
    float discr = b * b - c;

    //a negative discriminant corresponds to ray missing sphere
    if(discr < 0.0)
        return false;
    
    //ray now found to intersect sphere, compute smallest t value of intersection
    bool fromInside = false;
    float dist = -b - sqrt(discr);
    if (dist < 0.0f)
    {
        fromInside = true;
        dist = -b + sqrt(discr);
    }
    
    if (dist > c_minimumRayHitTime && dist < info.dist)
    {
        info.dist = dist;        
        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);
        return true;
    }
    
    return false;
}

void TestSceneTrace(in vec3 rayPos, in vec3 rayDir, inout hitInfo info)
{    
    // to move the scene around, since we can't move the camera yet
    // vec3 sceneTranslation = vec3(0.0f, 0.0f, 10.0f);
    // vec4 sceneTranslation4 = vec4(sceneTranslation, 0.0f);
    
    // back wall
    {
        vec3 A = vec3(-12.6f, -12.6f, 25.0f);
        vec3 B = vec3( 12.6f, -12.6f, 25.0f);
        vec3 C = vec3( 12.6f,  12.6f, 25.0f);
        vec3 D = vec3(-12.6f,  12.6f, 25.0f);
        if (TestQuadTrace(rayPos, rayDir, info, A, B, C, D))
        {
            info.material.albedo = vec3(0.7f, 0.7f, 0.7f);
            info.material.emissive = vec3(0.0f, 0.0f, 0.0f);
            info.material.percentSpecular = 0.0f;
            info.material.roughness = 0.0f;
            info.material.specularColor = vec3(0.0f, 0.0f, 0.0f);
        }
    }    
    
    // floor
    {
        vec3 A = vec3(-12.6f, -12.45f, 25.0f);
        vec3 B = vec3( 12.6f, -12.45f, 25.0f);
        vec3 C = vec3( 12.6f, -12.45f, 15.0f);
        vec3 D = vec3(-12.6f, -12.45f, 15.0f);
        if (TestQuadTrace(rayPos, rayDir, info, A, B, C, D))
        {
            info.material.albedo = vec3(0.7f, 0.7f, 0.7f);
            info.material.emissive = vec3(0.0f, 0.0f, 0.0f);
            info.material.percentSpecular = 0.0f;
            info.material.roughness = 0.0f;
            info.material.specularColor = vec3(0.0f, 0.0f, 0.0f);
        }        
    }
    
    // cieling
    {
        vec3 A = vec3(-12.6f, 12.5f, 25.0f);
        vec3 B = vec3( 12.6f, 12.5f, 25.0f);
        vec3 C = vec3( 12.6f, 12.5f, 15.0f);
        vec3 D = vec3(-12.6f, 12.5f, 15.0f);
        if (TestQuadTrace(rayPos, rayDir, info, A, B, C, D))
        {
            info.material.albedo = vec3(0.7f, 0.7f, 0.7f);
            info.material.emissive = vec3(0.0f, 0.0f, 0.0f);
            info.material.percentSpecular = 0.0f;
            info.material.roughness = 0.0f;
            info.material.specularColor = vec3(0.0f, 0.0f, 0.0f);
        }        
    }    
    
    // left wall
    {
        vec3 A = vec3(-12.5f, -12.6f, 25.0f);
        vec3 B = vec3(-12.5f, -12.6f, 15.0f);
        vec3 C = vec3(-12.5f,  12.6f, 15.0f);
        vec3 D = vec3(-12.5f,  12.6f, 25.0f);
        if (TestQuadTrace(rayPos, rayDir, info, A, B, C, D))
        {
            info.material.albedo = vec3(0.7f, 0.1f, 0.1f);
            info.material.emissive = vec3(0.0f, 0.0f, 0.0f);
            info.material.percentSpecular = 0.0f;
            info.material.roughness = 0.0f;
            info.material.specularColor = vec3(0.0f, 0.0f, 0.0f);
        }        
    }
    
    // right wall 
    {
        vec3 A = vec3( 12.5f, -12.6f, 25.0f);
        vec3 B = vec3( 12.5f, -12.6f, 15.0f);
        vec3 C = vec3( 12.5f,  12.6f, 15.0f);
        vec3 D = vec3( 12.5f,  12.6f, 25.0f);
        if (TestQuadTrace(rayPos, rayDir, info, A, B, C, D))
        {
            info.material.albedo = vec3(0.1f, 0.7f, 0.1f);
            info.material.emissive = vec3(0.0f, 0.0f, 0.0f);
            info.material.percentSpecular = 0.0f;
            info.material.roughness = 0.0f;
            info.material.specularColor = vec3(0.0f, 0.0f, 0.0f);
        }        
    }    
    
    // light
    {
        vec3 A = vec3(-5.0f, 12.4f,  22.5f);
        vec3 B = vec3( 5.0f, 12.4f,  22.5f);
        vec3 C = vec3( 5.0f, 12.4f,  17.5f);
        vec3 D = vec3(-5.0f, 12.4f,  17.5f);
        if (TestQuadTrace(rayPos, rayDir, info, A, B, C, D))
        {
            info.material.albedo = vec3(0.0f, 0.0f, 0.0f);
            info.material.emissive = vec3(1.0f, 0.9f, 0.7f) * 20.0f;
            info.material.percentSpecular = 0.0f;
            info.material.roughness = 0.0f;
            info.material.specularColor = vec3(0.0f, 0.0f, 0.0f);
        }        
    }
    
    if (TestSphereTrace(rayPos, rayDir, info, vec4(-9.0f, -9.5f, 20.0f, 3.0f)))
    {
        info.material.albedo = vec3(0.9f, 0.9f, 0.5f);
        info.material.emissive = vec3(0.0f, 0.0f, 0.0f);        
        info.material.percentSpecular = 0.1f;
        info.material.roughness = 0.2f;
        info.material.specularColor = vec3(0.9f, 0.9f, 0.9f);        
    } 
    
    if (TestSphereTrace(rayPos, rayDir, info, vec4(0.0f, -9.5f, 20.0f, 3.0f)))
    {
        info.material.albedo = vec3(0.9f, 0.5f, 0.9f);
        info.material.emissive = vec3(0.0f, 0.0f, 0.0f);   
        info.material.percentSpecular = 0.3f;
        info.material.roughness = 0.2;
        info.material.specularColor = vec3(0.9f, 0.9f, 0.9f);        
    }    
    
    if (TestSphereTrace(rayPos, rayDir, info, vec4(9.0f, -9.5f, 20.0f, 3.0f)))
    {
        info.material.albedo = vec3(0.0f, 0.0f, 1.0f);
        info.material.emissive = vec3(0.0f, 0.0f, 0.0f);
        info.material.percentSpecular = 0.5f;
        info.material.roughness = 0.4f;
        info.material.specularColor = vec3(1.0f, 0.0f, 0.0f);
    } 

    // shiny green balls of varying roughnesses
    {
        if (TestSphereTrace(rayPos, rayDir, info, vec4(-10.0f, 0.0f, 23.0f, 1.75f)))
        {
            info.material.albedo = vec3(1.0f, 1.0f, 1.0f);
            info.material.emissive = vec3(0.0f, 0.0f, 0.0f);        
            info.material.percentSpecular = 1.0f;
            info.material.roughness = 0.0f;
            info.material.specularColor = vec3(0.3f, 1.0f, 0.3f);       
        }     
        
        if (TestSphereTrace(rayPos, rayDir, info, vec4(-5.0f, 0.0f, 23.0f, 1.75f)))
        {
            info.material.albedo = vec3(1.0f, 1.0f, 1.0f);
            info.material.emissive = vec3(0.0f, 0.0f, 0.0f);        
            info.material.percentSpecular = 1.0f;
            info.material.roughness = 0.25f;
            info.material.specularColor = vec3(0.3f, 1.0f, 0.3f);
        }            
        
        if (TestSphereTrace(rayPos, rayDir, info, vec4(0.0f, 0.0f, 23.0f, 1.75f)))
        {
            info.material.albedo = vec3(1.0f, 1.0f, 1.0f);
            info.material.emissive = vec3(0.0f, 0.0f, 0.0f);        
            info.material.percentSpecular = 1.0f;
            info.material.roughness = 0.5f;
            info.material.specularColor = vec3(0.3f, 1.0f, 0.3f);
        }            
        
        if (TestSphereTrace(rayPos, rayDir, info, vec4(5.0f, 0.0f, 23.0f, 1.75f)))
        {
            info.material.albedo = vec3(1.0f, 1.0f, 1.0f);
            info.material.emissive = vec3(0.0f, 0.0f, 0.0f);        
            info.material.percentSpecular = 1.0f;
            info.material.roughness = 0.75f;
            info.material.specularColor = vec3(0.3f, 1.0f, 0.3f);
        }        
        
        if (TestSphereTrace(rayPos, rayDir, info, vec4(10.0f, 0.0f, 23.0f, 1.75f)))
        {
            info.material.albedo = vec3(1.0f, 1.0f, 1.0f);
            info.material.emissive = vec3(0.0f, 0.0f, 0.0f);        
            info.material.percentSpecular = 1.0f;
            info.material.roughness = 1.0f;
            info.material.specularColor = vec3(0.3f, 1.0f, 0.3f);
        }           
    }           
}
 
vec3 GetColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout searchInfo search)
{
    // initialize
    vec3 ret = vec3(0.0f, 0.0f, 0.0f);
    vec3 throughput = vec3(1.0f, 1.0f, 1.0f);
    vec3 rayPos = startRayPos;
    vec3 rayDir = startRayDir;
     
    for (int bounceIndex = 0; bounceIndex <= c_numBounces; ++bounceIndex)
    {
        // shoot a ray out into the world
        hitInfo info;
        info.dist = c_superFar;
        TestSceneTrace(rayPos, rayDir, info);
         
        // if the ray missed, we are done
        if (info.dist == c_superFar)
        {
            ret += SRGBToLinear(texture(envTex, rayDir).rgb) * c_skyboxBrightnessMultiplier * throughput;
            break;
        }
        //glossy relections!!!

        // update the ray position
        rayPos = (rayPos + rayDir * info.dist) + info.normal * c_rayPosNormalNudge;
        
        // calculate whether we are going to do a diffuse or specular reflection ray 
        float doSpecular = (hash1(search) < info.material.percentSpecular) ? 1.0f : 0.0f;
 
        // Calculate a new ray direction.
        // Diffuse uses a normal oriented cosine weighted hemisphere sample.
        // Perfectly smooth specular uses the reflection ray.
        // Rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared
        // Squaring the roughness is just a convention to make roughness feel more linear perceptually.
        vec3 diffuseRayDir = normalize(info.normal + random_in_unit_sphere(search));
        vec3 specularRayDir = reflect(rayDir, info.normal);
        specularRayDir = normalize(mix(specularRayDir, diffuseRayDir, info.material.roughness * info.material.roughness));
        rayDir = mix(diffuseRayDir, specularRayDir, doSpecular);

        // add in emissive lighting
        ret += info.material.emissive * throughput;
 
        // update the colorMultiplier
        throughput *= mix(info.material.albedo, info.material.specularColor, doSpecular);

        //  Russian Roulette (make Cornell Box transparent in Jitter)
        // As the throughput gets smaller, the ray is more likely to get terminated early.
        // Survivors have their value boosted to make up for fewer samples being in the average.
        // {
        //     float p = max(throughput.r, max(throughput.g, throughput.b));
        //     if (hash1(search) > p)
        //         break;

        //     // Add the energy we 'lose' by randomly terminating paths
        //     throughput *= 1.0f / p;            
        // }

        // diffuse materials

        // update the ray position
        // rayPos = (rayPos + rayDir * info.dist) + info.normal * c_rayPosNormalNudge;
         
        // // calculate new ray direction, in a cosine weighted hemisphere oriented at normal
        // rayDir = normalize(info.normal + random_in_unit_sphere(search));        
         
        // add in emissive lighting
        // ret += info.emissive * throughput;
         
        // update the colorMultiplier
        // throughput *= info.albedo;      
    }
  
    // return pixel color
    return ret;
}

void initializeRngState(out searchInfo search){
    search.rngState = float(base_hash(floatBitsToUint(jit_in.uv)))/float(0xffffffffU)+sample;
}

 
void GetCameraVectors(out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraUp, out vec3 cameraRight)
{
    // if the mouse is at (0,0) it hasn't been moved yet, so use a default camera setup
    vec2 mouse = iMouse.xy;
    if (dot(mouse, vec2(1.0f, 1.0f)) == 0.0f)
    {
        cameraPos = vec3(0.0f, 0.0f, -c_cameraDistance);
        cameraFwd = vec3(0.0f, 0.0f, 1.0f);
        cameraUp = vec3(0.0f, 1.0f, 0.0f);
        cameraRight = vec3(1.0f, 0.0f, 0.0f);
        return;
    }
     
    // otherwise use the mouse position to calculate camera position and orientation
     
    float angleX = -mouse.x * 16.0f / float(viewPort.x);
    float angleY = mix(c_minCameraAngle, c_maxCameraAngle, mouse.y / float(viewPort.y));
     
    cameraPos.x = sin(angleX) * sin(angleY) * c_cameraDistance;
    cameraPos.y = -cos(angleY) * c_cameraDistance;
    cameraPos.z = cos(angleX) * sin(angleY) * c_cameraDistance;
     
    cameraPos += c_cameraAt;
     
    cameraFwd = normalize(c_cameraAt - cameraPos);
    cameraRight = normalize(cross(vec3(0.0f, 1.0f, 0.0f), cameraFwd));
    cameraUp = normalize(cross(cameraFwd, cameraRight));   
}


void main(void) {

    searchInfo search;

    initializeRngState(search);

    // vec2 fragCoord = jit_in.uv * viewPort.xy;
    
    // uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);

    // get the camera vectors
    vec3 cameraPos, cameraFwd, cameraUp, cameraRight;
    GetCameraVectors(cameraPos, cameraFwd, cameraUp, cameraRight);    
    vec3 rayDir;
    { 

        // make a ray direction based on camera orientation and field of view angle
        float cameraDistance = tan(c_FOVDegrees * 0.79f * c_pi / 180.0f);

        vec2 screenPos = jit_in.uv*2-1;
        // correct for aspect ratio
        float aspectRatio = viewPort.x / viewPort.y;
        screenPos.x *= aspectRatio; //corrrect x axis -1.777 to 1,777
        //AntiAliasing
        vec2 jitter = hash2(search) - -0.5;
        jitter /= viewPort;
        screenPos += jitter*3;

               
        rayDir = vec3(screenPos, cameraDistance);
        rayDir = normalize(mat3(cameraRight, cameraUp, cameraFwd) * rayDir);
    }

	vec3 color = GetColorForRay(cameraPos, rayDir, search);

    // apply exposure (how long the shutter is open)
    color *= c_exposure;

    // convert unbounded HDR color range to SDR color range
    // color = ACESFilm(color);
 
    // convert from linear to sRGB for display
    // color = LinearToSRGB(color);

	outColor = vec4(color, 1);
}
]]>
</program>
</language>
</jittershader>
