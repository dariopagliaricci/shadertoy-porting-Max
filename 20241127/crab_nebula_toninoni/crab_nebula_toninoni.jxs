<jittershader name="default">
	<description>Default Slab </description>

	<param name="MVP" type="mat4" state="MODELVIEW_PROJECTION_MATRIX" />
	<param name="position" type="vec3" state="POSITION" />
	<param name="uv" type="vec2" state="TEXCOORD" />

	<param name="viewPort" type="vec2" state="VIEWPORT" />
	<param name="iTime" type="float" default="0.0" />
	<param name="iMouse" type="vec2" default="0 0" />
	<param name="iChannel0" type="int" default="0" />

	<language name="glsl" version="1.5">

		<bind param="MVP" program="vp" />
		<bind param="position" program="vp" />
		<bind param="uv" program="vp" />

		<bind param="viewPort" program="fp" />
		<bind param="iTime" program="fp" />
		<bind param="iMouse" program="fp" />
		<bind param="iChannel0" program="fp" />

		<program name="vp" type="vertex"  >
		<![CDATA[
			#version 330 core
			
			in vec3 position;
			in vec2 uv;

			out jit_PerVertex {
				vec2 uv;

			} jit_out;
			uniform mat4 MVP;

			
			void main(void) {
				gl_Position = MVP*vec4(position, 1.);
				jit_out.uv = uv;

			}
		]]>
		</program>
		
<program name="fp" type="fragment"  >
<![CDATA[
#version 330 core

in jit_PerVertex {
vec2 uv;

} jit_in;
layout (location = 0) out vec4 outColor;

uniform vec2 viewPort;
uniform float iTime;
uniform vec2 iMouse;
uniform sampler2D iChannel0;


// Fork of "Supernova remnant" by Duke
// https://www.shadertoy.com/view/MdKXzc
//-------------------------------------------------------------------------------------
// Based on "Dusty nebula 4" (https://www.shadertoy.com/view/MsVXWW) 
// and "Protoplanetary disk" (https://www.shadertoy.com/view/MdtGRl) 
// otaviogood's "Alien Beacon" (https://www.shadertoy.com/view/ld2SzK)
// and Shane's "Cheap Cloud Flythrough" (https://www.shadertoy.com/view/Xsc3R4) shaders
// Some ideas came from other shaders from this wonderful site
// Press 1-2-3 to zoom in and zoom out.
// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
//-------------------------------------------------------------------------------------

#define ITERATIONS 70

//-------------------
#define pi 3.14159265
#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)

mat4 rotate(vec3 axis, float angle)
{
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    
    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                0.0,                                0.0,                                0.0,                                1.0);
}

// iq's noise
float noise( in vec3 x ) {
    vec3 p = floor(x);
    vec3 f = fract(x);
	f = f*f*(3.0-2.0*f);
	vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;
	vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;
	return 1. - 0.82*mix( rg.x, rg.y, f.z );
}

float fbm(vec3 p) {
   return noise(p*.04125)*.5 + noise(p*.125)*.25 + noise(p*.25)*.125 + noise(p*.4)*.2;
}

float length2( vec2 p ) {
	return sqrt( p.x*p.x + p.y*p.y );
}

float length8( vec2 p ) {
	p = p*p; p = p*p; p = p*p;
	return pow( p.x + p.y, 1.0/8.0 );
}


float Disk( vec3 p, vec3 t ) {
    vec2 q = vec2(length2(p.xy) -t.x,p.z*0.7);
    return max(length8(q)-t.y, abs(p.z) - t.z);
}

//==============================================================
// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK
//--------------------------------------------------------------
// This spiral noise works by successively adding and rotating sin waves while increasing frequency.
// It should work the same on all computers since it's not based on a hash function like some other noises.
// It can be much faster than other noise functions if you're ok with some repetition.
const float nudge = 0.9;	// size of perpendicular vector
float normalizer = 1.0 / sqrt(1.0 + nudge*nudge);	// pythagorean theorem on that perpendicular to maintain scale
float SpiralNoiseC(vec3 p) {
    float n = 0.0;	// noise amount
    float iter = 2.0;
    for (int i = 0; i < 8; i++)
    {
        // add sin and cos scaled inverse with the frequency
        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;	// abs for a ridged look
        // rotate by adding perpendicular and scaling down
        p.xy += vec2(p.y, -p.x) * nudge;
        p.xy *= normalizer;
        // rotate on other axis
        p.xz += vec2(p.z, -p.x) * nudge;
        p.xz *= normalizer;
        // increase the frequency
        iter *= 1.733733;
    }
    return n;
}

float NebulaNoise(vec3 p) {
    float final = Disk(p.xzy,vec3(2.0,2.0,0.3));
    final += fbm(p*60.0);
    final += SpiralNoiseC(p.zxy*0.7+1.6)*2.0;

    return final;
}

float map(vec3 p) {
	R(p.xz, iMouse.x*0.008*pi+iTime*0.1);
    
    p = (vec4(p,1.0) * rotate(vec3(1.0, 0.0, 0.0), pi / 4.0)).rgb;

	float NebNoise = abs(NebulaNoise(p/0.5)*0.5);
    
	return NebNoise+0.07;
}
//--------------------------------------------------------------

// assign color to the media
vec3 computeColor( float density, float radius )
{
	// color based on density alone, gives impression of occlusion within
	// the media
	//vec3 result = mix( vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), density );
	vec3 result = mix( vec3(1.0), vec3(0.5), density );
    
	// color added to the media
	vec3 colCenter = 7.*vec3(0.8,0.9,1.0).rgb;
	vec3 colEdge = 1.5*vec3(0.48,0.53,0.5).rgb;
	result *= mix( colCenter, colEdge, min( (radius+.05)/.9, 1.15 ) );
	
	return result;
}

bool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)
{
	float b = dot(dir, org);
	float c = dot(org, org) - 10.0;
	float delta = b*b - c;
	if( delta < 0.0) 
		return false;
	float deltasqrt = sqrt(delta);
	near = -b - deltasqrt;
	far = -b + deltasqrt;
	return far > 0.0;
}


void main() {  
    
    vec2 fragCoord = jit_in.uv * viewPort.xy;
    float zoom = (iMouse.y / viewPort.y) * 2.0;

	// ro: ray origin
	// rd: direction of the ray
	vec3 rd = normalize(vec3((fragCoord.xy-0.5*viewPort.xy)/viewPort.y, 1.));
	vec3 ro = vec3(0., 0., -6.*1.6 + (5.0 * zoom));
    
	// ld, td: local, total density 
	// w: weighting factor
	float ld=0., td=0., w=0.;

	// t: length of the ray
	// d: distance function
	float d=1., t=0.;
    
    const float h = 0.1;
   
	vec4 sum = vec4(0.0);
   
    float min_dist=0.0, max_dist=0.0;

    if(RaySphereIntersect(ro, rd, min_dist, max_dist))
    {
       
	t = min_dist*step(t,min_dist);
   
	// raymarch loop
	for (int i=0; i<ITERATIONS; i++) {
	 
		vec3 pos = ro + t*rd;
  
		// Loop break conditions.
	    if(td>0.9 || t>20. || sum.a > 0.99 || t>max_dist) break;
        
        // evaluate distance function
        float d = map(pos);
		       
		// change this string to control density 
		d = max(d,0.0);
        
        // point light calculations
        vec3 ldst = vec3(0.0)-pos;
        float lDist = max(length(ldst), 0.001);

        // the color of light 
        float _T = lDist*2.3+2.6; // <-v endless tweaking
        //_T -= iTime*0.5;
        vec3 lightColor=0.4+0.5*cos(_T + pi * 0.5*vec3(-0.5,0.05,0.5)); //vec3(1.0,0.5,0.25);
        
        // Star
        sum.rgb+=(vec3(0.57,1.85,1.00)/(lDist*lDist*10.)/70.0);
        // Bloom
        sum.rgb+=(lightColor/exp(lDist*lDist*lDist*.05)/30.0);
        
		if (d<h) {
			// compute local density 
			ld = h - d;
            
            // compute weighting factor 
			w = (1. - td) * ld;
     
			// accumulate density
			td += w + 1./200.;
		
			vec4 col = vec4( computeColor(td,lDist), td );
            
            // emission
            sum += sum.a * vec4(sum.rgb, 0.0) * 0.2;	
            
			// uniform scale density
			col.a *= 0.2;
			// colour by alpha
			col.rgb *= col.a;
			// alpha blend in contribution
			sum = sum + col*(1.0 - sum.a);  
       
		}
      
		td += 1./70.;

		
        // trying to optimize step size near the camera and near the light source
        t += max(d * 0.1 * max(min(length(ldst),length(ro)),1.0), 0.01);
        
	}
    
    // simple scattering
	sum *= 1. / exp( ld * 0.2 ) * 0.6;
        
   	sum = clamp( sum, 0.0, 1.0 );
   
    sum.xyz = sum.xyz*sum.xyz*(3.0-2.0*sum.xyz);
    
	}

    outColor = vec4(sum.xyz,1.0);
}
]]>
</program>
</language>
</jittershader>
