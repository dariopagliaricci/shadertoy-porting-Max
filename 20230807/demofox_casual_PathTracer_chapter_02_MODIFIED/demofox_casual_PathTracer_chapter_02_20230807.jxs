<jittershader name="default">
	<description>Default Slab </description>


	<param name="MVP" type="mat4" state="MODELVIEW_PROJECTION_MATRIX" />

	<param name="pos" type="vec3" state="POSITION" />
	<param name="uv" type="vec2" state="TEXCOORD" />
	<param name="viewPort" type="vec2" state="VIEWPORT" />
	<param name="eye" type="vec3" state="CAMERA_POSITION" />

	<param name="envTex" type="int" default="0" />
	<param name="sample" type="float" default="0.0" />

    <param name="aperture" type="float" default="0.1" />
    <param name="DoFdist" type="float" default="0" />

	<language name="glsl" version="1.5">


		<bind param="MVP" program="vp" />
		<bind param="pos" program="vp" />
		<bind param="uv" program="vp" />
		<bind param="viewPort" program="fp" />
		<bind param="eye" program="fp" />

		<bind param="envTex" program="fp" />
		<bind param="sample" program="fp" />

        <bind param="aperture" program="fp" />
        <bind param="DoFdist" program="fp" />

		<program name="vp" type="vertex"  >
		<![CDATA[
			#version 330 core
			
			in vec3 pos;
			in vec2 uv;

			out jit_PerVertex {
				vec2 uv;

			} jit_out;
			uniform mat4 MVP;

			
			void main(void) {
				gl_Position = vec4(pos, 1.);
				jit_out.uv = uv;

			}
		]]>
		</program>
		
		<program name="fp" type="fragment"  >
		<![CDATA[
#version 330 core
#define BOUNCES 8
#define VERY_FAR 100000000
#define TWOPI 6.2831855

uniform vec2 viewPort;
uniform vec3 eye;
uniform float sample;
uniform float aperture;
uniform float DoFDist;

uniform samplerCube envTex;
uniform samplerBuffer sphereBuff, albBuff, emiBuff, refInfoBuff;

struct rayInfo {
    vec3 origin;
    vec3 dir;
};

struct hitInfo{
    float t0;
    vec3 nor;
};

struct matInfo{
    vec3 alb;
    vec3 emi;
    float roughness;
    float f0;
    float IOR;
};

struct searchInfo {
    float rngState;
    vec3 finalColor;
    vec3 through;
};

in jit_PerVertex {
vec2 uv;
} jit_in;

layout (location = 0) out vec4 outColor;

// Hash functions by Nimitz:
// https://www.shadertoy.com/view/Xt3cDn

uint base_hash(uvec2 p) {
    p = 1103515245U*((p >> 1U)^(p.yx));
    uint h32 = 1103515245U*((p.x)^(p.y>>3U));
    return h32^(h32 >> 16);
}

float g_seed = 0.;

float hash1(inout searchInfo search) {
    uint n = base_hash(floatBitsToUint(vec2(search.rngState+=.1,search.rngState+=.1)));
    return float(n)/float(0xffffffffU);
}

vec2 hash2(inout searchInfo search) {
    uint n = base_hash(floatBitsToUint(vec2(search.rngState+=.1,search.rngState+=.1)));
    uvec2 rz = uvec2(n, n*48271U);
    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);
}

vec3 hash3(inout searchInfo search) {
    uint n = base_hash(floatBitsToUint(vec2(search.rngState+=.1,search.rngState+=.1)));
    uvec3 rz = uvec3(n, n*16807U, n*48271U);
    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);
}

//https://www.shadertoy.com/view/tddSz4 (Adapted)

vec3 random_in_unit_sphere(inout searchInfo search) {
    vec3 h = hash3(search) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);
    float phi = h.y;
    float r = pow(h.z, 1./3.);
    return r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);
}

float ScalarTriple(vec3 u, vec3 v, vec3 w)
{
    return dot(cross(u, v), w);
}

void TestQuadTrace(inout rayInfo ray, inout hitInfo hit, inout matInfo mat, in vec3 a, in vec3 b, in vec3 c, in vec3 d, vec3 color, vec3 emissive, vec3 rouF0IOR)
{
    // calculate normal and flip vertices order if needed
    vec3 normal = normalize(cross(c-a, c-b));
    if (dot(normal, ray.dir) > 0.0f)
    {
        normal *= -1.0f;
        
        vec3 temp = d;
        d = a;
        a = temp;
        
        temp = b;
        b = c;
        c = temp;
    }
    
    vec3 p = ray.origin;
    vec3 q = ray.origin + ray.dir;
    vec3 pq = q - p;
    vec3 pa = a - p;
    vec3 pb = b - p;
    vec3 pc = c - p;
    
    // determine which triangle to test against by testing against diagonal first
    vec3 m = cross(pc, pq);
    float v = dot(pa, m);
    vec3 intersectPos;
    if (v >= 0.0f)
    {
        // test against triangle a,b,c
        float u = -dot(pb, m);
        if (u < 0.0f) return;
        float w = ScalarTriple(pq, pb, pa);
        if (w < 0.0f) return;
        float denom = 1.0f / (u+v+w);
        u*=denom;
        v*=denom;
        w*=denom;
        intersectPos = u*a+v*b+w*c;
    }
    else
    {
        vec3 pd = d - p;
        float u = dot(pd, m);
        if (u < 0.0f) return;
        float w = ScalarTriple(pq, pa, pd);
        if (w < 0.0f) return;
        v = -v;
        float denom = 1.0f / (u+v+w);
        u*=denom;
        v*=denom;
        w*=denom;
        intersectPos = u*a+v*d+w*c;
    }
    
    float dist;
    if (abs(ray.dir.x) > 0.1f)
    {
        dist = (intersectPos.x - ray.origin.x) / ray.dir.x;
    }
    else if (abs(ray.dir.y) > 0.1f)
    {
        dist = (intersectPos.y - ray.origin.y) / ray.dir.y;
    }
    else
    {
        dist = (intersectPos.z - ray.origin.z) / ray.dir.z;
    }
    
    if(dist < hit.t0) //(dist > c_minimumRayHitTime && dist < info.dist)
    {
        hit.t0 = dist;        
        hit.nor = normal;
        mat.alb = color;
        mat.emi = emissive;
        mat.roughness = rouF0IOR.x;
        mat.f0 = rouF0IOR.y;
        mat.IOR= rouF0IOR.z;
        return;
    }    
    
    return;
}
// https://www.shadertoy.com/view/tsBBWW (adapted)

void TestSphereTrace(in rayInfo ray, inout hitInfo hit, inout matInfo mat, in vec4 sphere, vec3 color, vec3 emissive, vec3 rouF0IOR)
{
    //get the vector from the center of this sphere to where the ray begins.
    vec3 m = ray.origin - sphere.xyz;

    //get the dot product of the above vector and the ray's vector
    float b = dot(m, ray.dir);

    float c = dot(m, m) - sphere.w * sphere.w;

    //exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
    if(c > 0.0 && b > 0.0)
        return;

    //calculate discriminant
    float discr = b * b - c;

    //a negative discriminant corresponds to ray missing sphere
    if(discr < 0.0)
        return;
    
    //ray now found to intersect sphere, compute smallest t value of intersection
    bool fromInside = false;
    float dist = -b - sqrt(discr);
    if (dist < 0.0f)
    {
        fromInside = true;
        dist = -b + sqrt(discr);
    }
    
    if (dist < hit.t0) //(dist > c_minimumRayHitTime && dist < info.dist)
    {
        hit.t0 = dist;        
        hit.nor = normalize((ray.origin+ray.dir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);
        mat.alb = color;
        mat.emi = emissive;
        mat.roughness = rouF0IOR.x;
        mat.f0 = rouF0IOR.y;
        mat.IOR= rouF0IOR.z;
        return;
    }
    
    return;
}

void TestSceneTrace(inout rayInfo ray, inout hitInfo hit, inout matInfo mat)
{    
    
    // back wall
    {
        vec3 A = vec3(-12.6f, -12.6f, 25.0f);
        vec3 B = vec3( 12.6f, -12.6f, 25.0f);
        vec3 C = vec3( 12.6f,  12.6f, 25.0f);
        vec3 D = vec3(-12.6f,  12.6f, 25.0f);
        TestQuadTrace(ray, hit, mat, A, B, C, D, vec3(0.7f, 0.7f, 0.7f), vec3(0.0f, 0.0f, 0.0f), vec3(0.2f, 0.9f, 1.4f));
    }

    // floor
    {
        vec3 A = vec3(-12.6f, -12.45f, 25.0f);
        vec3 B = vec3( 12.6f, -12.45f, 25.0f);
        vec3 C = vec3( 12.6f, -12.45f, 15.0f);
        vec3 D = vec3(-12.6f, -12.45f, 15.0f);
        TestQuadTrace(ray, hit, mat, A, B, C, D, vec3(0.7f, 0.7f, 0.7f), vec3(0.0f, 0.0f, 0.0f), vec3(0.0f, 0.0f, 0.0f));      
    }
    
    // cieling
    {
        vec3 A = vec3(-12.6f, 12.5f, 25.0f);
        vec3 B = vec3( 12.6f, 12.5f, 25.0f);
        vec3 C = vec3( 12.6f, 12.5f, 15.0f);
        vec3 D = vec3(-12.6f, 12.5f, 15.0f);
        TestQuadTrace(ray, hit, mat, A, B, C, D, vec3(0.7f, 0.7f, 0.7f), vec3(0.0f, 0.0f, 0.0f), vec3(0.0f, 0.0f, 0.0f));
    }    
    
    // left wall
    {
        vec3 A = vec3(-12.5f, -12.6f, 25.0f);
        vec3 B = vec3(-12.5f, -12.6f, 15.0f);
        vec3 C = vec3(-12.5f,  12.6f, 15.0f);
        vec3 D = vec3(-12.5f,  12.6f, 25.0f);
        TestQuadTrace(ray, hit, mat, A, B, C, D, vec3(0.7f, 0.1f, 0.1f), vec3(0.0f, 0.0f, 0.0f), vec3(0.0f, 0.0f, 0.0f));
    }
    
    // right wall 
    {
        vec3 A = vec3( 12.5f, -12.6f, 25.0f);
        vec3 B = vec3( 12.5f, -12.6f, 15.0f);
        vec3 C = vec3( 12.5f,  12.6f, 15.0f);
        vec3 D = vec3( 12.5f,  12.6f, 25.0f);
        TestQuadTrace(ray, hit, mat, A, B, C, D, vec3(0.1f, 0.7f, 0.1f), vec3(0.0f, 0.0f, 0.0f), vec3(0.0f, 0.0f, 0.0f));     
    }    
    
    // light
    {
        vec3 A = vec3(-5.0f, 12.4f,  22.5f);
        vec3 B = vec3( 5.0f, 12.4f,  22.5f);
        vec3 C = vec3( 5.0f, 12.4f,  17.5f);
        vec3 D = vec3(-5.0f, 12.4f,  17.5f);
        TestQuadTrace(ray, hit, mat, A, B, C, D, vec3(0.0f, 0.0f, 0.0f), vec3(1.0f, 0.9f, 0.7f) * 20.0f, vec3(0.0f, 0.0f, 0.0f));     
    }
    
    TestSphereTrace(ray, hit, mat, vec4(-9.0f, -9.5f, 20.0f, 3.0f), vec3(0.9f, 0.9f, 0.5f), vec3(0.0f, 0.0f, 0.0f), vec3(0.2f, 0.1f, 1.1));// vec3(0.9f, 0.9f, 0.9f));

    TestSphereTrace(ray, hit, mat, vec4(0.0f, -9.5f, 20.0f, 3.0f), vec3(0.9f, 0.5f, 0.9f), vec3(0.0f, 0.0f, 0.0f), vec3(0.2f, 0.3f, 1.1));// vec3(0.9f, 0.9f, 0.9f));
    
    // a ball which has blue diffuse but red specular. an example of a "bad material".
    // a better lighting model wouldn't let you do this sort of thing
    TestSphereTrace(ray, hit, mat, vec4(9.0f, -9.5f, 20.0f, 3.0f), vec3(0.0f, 0.0f, 1.0f), vec3(0.0f, 0.0f, 0.0f), vec3(0.4f, 0.5f, 1.1));//vec3(1.0f, 0.0f, 0.0f));
 
    // shiny green balls of varying roughnesses

    TestSphereTrace(ray, hit, mat, vec4(-10.0f, 0.0f, 23.0f, 1.75f), vec3(1.0f, 1.0f, 1.0f), vec3(0.0f, 0.0f, 0.0f), vec3(0.0f, 1.0f, 1.1));// vec3(0.3f, 1.0f, 0.3f));
  
    TestSphereTrace(ray, hit, mat, vec4(-5.0f, 0.0f, 23.0f, 1.75f), vec3(1.0f, 1.0f, 1.0f), vec3(0.0f, 0.0f, 0.0f), vec3(0.25f, 1.0f, 1.1)); //vec3(0.3f, 1.0f, 0.3f));    
             
    TestSphereTrace(ray, hit, mat, vec4(0.0f, 0.0f, 23.0f, 1.75f), vec3(1.0f, 1.0f, 1.0f), vec3(0.0f, 0.0f, 0.0f), vec3(0.5, 1.0f, 1.1));// vec3(0.3f, 1.0f, 0.3f));    
          
    TestSphereTrace(ray, hit, mat, vec4(5.0f, 0.0f, 23.0f, 1.75f), vec3(1.0f, 1.0f, 1.0f), vec3(0.0f, 0.0f, 0.0f), vec3(0.75, 1.0f, 1.1));// vec3(0.3f, 1.0f, 0.3f));   
           
    TestSphereTrace(ray, hit, mat, vec4(10.0f, 0.0f, 23.0f, 1.75f), vec3(1.0f, 1.0f, 1.0f), vec3(0.0f, 0.0f, 0.0f), vec3(1.0f, 1.0f, 1.1));// vec3(0.3f, 1.0f, 0.3f));  
    
}


float planeIntersect(vec3 ro, vec3 rd, vec4 p){
    return -(dot(ro, p.xyz)+p.w)/dot(rd, p.xyz);
}

vec2 getBokehCircle(in searchInfo search){

    vec2 rand = hash2(search);
    float angle = rand.x*TWOPI;
    float radius = sqrt(rand.y);
    return vec2(cos(angle), sin(angle))*aperture*radius;
}

vec2 getBokehHexa(in searchInfo search){

    float sin30 = 0.5;
    float cos30 = 0.866;
    vec2 bokeh[7] = vec2[]  (   vec2(0, 1),
                                vec2(-cos30, sin30),
                                vec2(-cos30, -sin30),
                                vec2(0, -1),
                                vec2(cos30, -sin30),
                                vec2(cos30, sin30),
                                vec2(0, 1)
                            );

    vec2 rand = hash2(search);
    int index = int(floor(rand.x*6));
    float interp = fract(rand.x*6);
    float radius = sqrt(rand.y);
    return mix(bokeh[index], bokeh[index+1], interp)*aperture*radius;

}

void computeFirstRay(out rayInfo ray, inout searchInfo search){
    vec2 screenPos = jit_in.uv*2 - 1;
    float ratio = viewPort.x / viewPort.y;
    screenPos.x *= ratio;
    vec2 jittering = hash2(search) -0.5;
    jittering /= viewPort;
    screenPos += jittering*3;

    ray.origin = eye;
    //camera matrix
    vec3 target = vec3(0.);
    vec3 front = normalize(target - ray.origin);
    vec3 right = cross(vec3(0., 1., 0.), front);
    vec3 up = cross(front, right);

    vec3 pixPos = vec3(screenPos, 4);
    ray.dir = normalize(pixPos.x*right + pixPos.y*up + pixPos.z*front);

    float focalDist = 0;
    float focalPlane = planeIntersect(ray.origin, ray.dir, vec4(-front, DoFDist));
    vec3 focalPoint = ray.origin + ray.dir*focalPlane;

    vec2 cameraShift = getBokehHexa(search);
    float screenDist = planeIntersect(ray.origin, ray.dir, vec4(front, 4));
    ray.origin = eye + ray.dir*screenDist;
    ray.origin += right*cameraShift.x + up*cameraShift.y;
    ray.dir = normalize(focalPoint - ray.origin);
}



void rayTrace(in rayInfo ray, inout hitInfo hit, inout matInfo mat, inout searchInfo search){
    
    hit.t0 = VERY_FAR;
    // TestSceneTrace(ray, hit, mat);
    TestSphereTrace(ray, hit, mat, vec4(-9.0f, -9.5f, 20.0f, 3.0f), vec3(0.9f, 0.9f, 0.5f), vec3(0.0f, 0.0f, 0.0f), vec3(0.2f, 0.1f, 0.9));// vec3(0.9f, 0.9f, 0.9f));

    TestSphereTrace(ray, hit, mat, vec4(0.0f, -9.5f, 20.0f, 3.0f), vec3(0.9f, 0.5f, 0.9f), vec3(0.0f, 0.0f, 0.0f), vec3(0.2f, 0.3f, 1.1));// vec3(0.9f, 0.9f, 0.9f));
    
    // a ball which has blue diffuse but red specular. an example of a "bad material".
    // a better lighting model wouldn't let you do this sort of thing
    TestSphereTrace(ray, hit, mat, vec4(9.0f, -9.5f, 20.0f, 3.0f), vec3(0.0f, 0.0f, 1.0f), vec3(0.0f, 0.0f, 0.0f), vec3(0.4f, 0.5f, 1.1));//vec3(1.0f, 0.0f, 0.0f));
 
    // shiny green balls of varying roughnesses

    TestSphereTrace(ray, hit, mat, vec4(-10.0f, 0.0f, 23.0f, 1.75f), vec3(1.0f, 1.0f, 1.0f), vec3(0.0f, 0.0f, 0.0f), vec3(0.0f, 1.0f, 1.1));// vec3(0.3f, 1.0f, 0.3f));
  
    TestSphereTrace(ray, hit, mat, vec4(-5.0f, 0.0f, 23.0f, 1.75f), vec3(1.0f, 1.0f, 1.0f), vec3(0.0f, 0.0f, 0.0f), vec3(0.25f, 1.0f, 1.1)); //vec3(0.3f, 1.0f, 0.3f));    
             
    TestSphereTrace(ray, hit, mat, vec4(0.0f, 0.0f, 23.0f, 1.75f), vec3(1.0f, 1.0f, 1.0f), vec3(0.0f, 0.0f, 0.0f), vec3(0.5, 1.0f, 1.1));// vec3(0.3f, 1.0f, 0.3f));    
          
    TestSphereTrace(ray, hit, mat, vec4(5.0f, 0.0f, 23.0f, 1.75f), vec3(1.0f, 1.0f, 1.0f), vec3(0.0f, 0.0f, 0.0f), vec3(0.75, 1.0f, 1.1));// vec3(0.3f, 1.0f, 0.3f));   
           
    TestSphereTrace(ray, hit, mat, vec4(10.0f, 0.0f, 23.0f, 1.75f), vec3(1.0f, 1.0f, 1.0f), vec3(0.0f, 0.0f, 0.0f), vec3(1.0f, 1.0f, 1.1));// vec3(0.3f, 1.0f, 0.3f));  
    
    // // back wall
    // {
    //     vec3 A = vec3(-12.6f, -12.6f, 25.0f);
    //     vec3 B = vec3( 12.6f, -12.6f, 25.0f);
    //     vec3 C = vec3( 12.6f,  12.6f, 25.0f);
    //     vec3 D = vec3(-12.6f,  12.6f, 25.0f);
    //     TestQuadTrace(ray, hit, mat, A, B, C, D, vec3(0.7f, 0.7f, 0.7f), vec3(0.0f, 0.0f, 0.0f), vec3(0.2f, 0.9f, 1.4f));
    // }

    // // light
    // {
    //     vec3 A = vec3(-5.0f, 12.4f,  22.5f);
    //     vec3 B = vec3( 5.0f, 12.4f,  22.5f);
    //     vec3 C = vec3( 5.0f, 12.4f,  17.5f);
    //     vec3 D = vec3(-5.0f, 12.4f,  17.5f);
    //     TestQuadTrace(ray, hit, mat, A, B, C, D, vec3(0.0f, 0.0f, 0.0f), vec3(1.0f, 0.9f, 0.7f) * 20.0f, vec3(0.2f, 0.9f, 1.4f));     
    // }

    // for(int i = 0; i < 80; i++){
    //     TestSphereTrace(ray, hit, mat, sphere, alb, emissive, rouF0IOR);
    // }
        return;
    }

void miss(inout searchInfo search, in rayInfo ray){
    search.finalColor += texture(envTex, ray.dir).rgb * search.through;
    
}

void updateColor(inout matInfo mat, inout searchInfo search){
    search.finalColor += mat.emi*search.through;
    search.through *= mat.alb;
}

//https://blog.demofox.org/2020/06/14/casual-shadertoy-path-tracing-3-fresnel-rough-refraction-absorption-orbit-camera/
float FresnelReflectAmount(in rayInfo ray, in hitInfo hit, float n1, float n2, float f0, float f90)
{
        // Schlick aproximation
        float r0 = (n1-n2) / (n1+n2);
        r0 *= r0;
        float cosX = -dot(hit.nor, ray.dir);
        if (n1 > n2)
        {
            float n = n1/n2;
            float sinT2 = n*n*(1.0-cosX*cosX);
            // Total internal reflection
            if (sinT2 > 1.0)
                return f90;
            cosX = sqrt(1.0-sinT2);
        }
        float x = 1.0-cosX;
        float ret = r0+(1.0-r0)*x*x*x*x*x;
 
        // adjust reflect multiplier for object reflectivity
        return mix(f0, f90, ret);
}


void createNewRay(inout rayInfo ray, inout hitInfo hit, inout matInfo mat, inout searchInfo search){
    
    float airIOR = 1.000293;
    float matIOR = mat.IOR;
    float f0 = mat.f0;
    float f90 = 1;
    float fresnel = FresnelReflectAmount(ray, hit, airIOR, mat.IOR, mat.f0, f90);
    vec3 hitPos = ray.origin + ray.dir*hit.t0;
    ray.origin = hitPos;
    ray.origin += 0.001*hit.nor;//avoid false intersections
    vec3 spe = reflect(ray.dir, hit.nor);
    vec3 dif = normalize(random_in_unit_sphere(search)+hit.nor);
    float randChoice = hash1(search);

    if (randChoice > fresnel) {
        ray.dir = dif;
    } else {
        spe = mix(spe, dif, mat.roughness*mat.roughness);
        ray.dir = spe;
    }

}

void getFragmentColor(inout rayInfo ray, inout hitInfo hit, inout matInfo mat, inout searchInfo search) {
    
    search.through = vec3(1);
    search.finalColor = vec3(0.);
    for(int i = 0; i < BOUNCES; i++){
        rayTrace(ray, hit, mat, search);
        if(hit.t0 == VERY_FAR){
            miss(search, ray);
            return;
            }
        updateColor(mat, search);
        createNewRay(ray, hit, mat, search);
    }
    return;
}
//         // if the ray missed, we are done
//         if (hitInfo.dist == c_superFar)
//         {
//             ret += SRGBToLinear(texture(envTex, rayDir).rgb) * c_skyboxBrightnessMultiplier * throughput;
//             break;
//         }

//         // calculate whether we are going to do a diffuse or specular reflection ray 
//         float doSpecular = (RandomFloat01(rngState) < hitInfo.material.percentSpecular) ? 1.0f : 0.0f;
 
        
//         // update the ray position
//         rayPos = (rayPos + rayDir * hitInfo.dist) + hitInfo.normal * c_rayPosNormalNudge;
        
//         // Calculate a new ray direction.
//         // Diffuse uses a normal oriented cosine weighted hemisphere sample.
//         // Perfectly smooth specular uses the reflection ray.
//         // Rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared
//         // Squaring the roughness is just a convention to make roughness feel more linear perceptually.
//         vec3 diffuseRayDir = normalize(hitInfo.normal + RandomUnitVector(rngState));
//         vec3 specularRayDir = reflect(rayDir, hitInfo.normal);
//         specularRayDir = normalize(mix(specularRayDir, diffuseRayDir, hitInfo.material.roughness * hitInfo.material.roughness));
//         rayDir = mix(diffuseRayDir, specularRayDir, doSpecular);

void initializeRngState(out searchInfo search) {

    search.rngState = float(base_hash(floatBitsToUint(jit_in.uv)))/float(0xffffffffU)+sample;
}
 
void main(){
    
    rayInfo ray;
    hitInfo hit;
    matInfo mat;
    searchInfo search;
    
    initializeRngState(search);
    computeFirstRay(ray, search);
    getFragmentColor(ray, hit, mat, search);

    outColor.rgb = search.finalColor;
    outColor.a = 1;
    // outColor.rgb = vec3(hash1(search));
}




// // #define BOUNCES 8
// // #define VERY_FAR 1e8
// #define TWOPI 6.2831855

// // The minimunm distance a ray must travel before we consider an intersection.
// // This is to prevent a ray from intersecting a surface it just bounced off of.
// const float c_minimumRayHitTime = 0.01f;

// // after a hit, it moves the ray this far along the normal away from a surface.
// // Helps prevent incorrect intersections when rays bounce off of objects.
// const float c_rayPosNormalNudge = 0.01f;

// // the farthest we look for ray hits
// const float c_superFar = 10000.0f;

// // camera FOV
// const float c_FOVDegrees = 90.0f;

// // number of ray bounces allowed max
// const int c_numBounces = 8;

// // a multiplier for the skybox brightness
// const float c_skyboxBrightnessMultiplier = 2.0f;
    
// // a pixel value multiplier of light before tone mapping and sRGB
// const float c_exposure = 0.5f; 

// // how many renders per frame - make this larger to get around the vsync limitation, and get a better image faster.
// const int c_numRendersPerFrame = 8;

// const float c_pi = 3.14159265359f;
// const float c_twopi = 2.0f * c_pi;


// vec3 LessThan(vec3 f, float value)
// {
//     return vec3(
//         (f.x < value) ? 1.0f : 0.0f,
//         (f.y < value) ? 1.0f : 0.0f,
//         (f.z < value) ? 1.0f : 0.0f);
// }

// vec3 LinearToSRGB(vec3 rgb)
// {
//     rgb = clamp(rgb, 0.0f, 1.0f);
    
//     return mix(
//         pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,
//         rgb * 12.92f,
//         LessThan(rgb, 0.0031308f)
//     );
// }

// vec3 SRGBToLinear(vec3 rgb)
// {
//     rgb = clamp(rgb, 0.0f, 1.0f);
    
//     return mix(
//         pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),
//         rgb / 12.92f,
//         LessThan(rgb, 0.04045f)
//     );
// }

// // ACES tone mapping curve fit to go from HDR to LDR
// //https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
// vec3 ACESFilm(vec3 x)
// {
//     float a = 2.51f;
//     float b = 0.03f;
//     float c = 2.43f;
//     float d = 0.59f;
//     float e = 0.14f;
//     return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);
// }

// uniform vec2 viewPort;
// uniform vec3 eye;
// // uniform float sample;
// uniform int iFrame;
// uniform float aperture, DoFdist;

// uniform samplerCube envTex;

// in jit_PerVertex {
// 	vec2 uv;

// } jit_in;
// layout (location = 0) out vec4 outColor;

// struct searchInfo {
//     float rngState;
//     vec3 finalColor;
//     vec3 through;
// };

// uint base_hash(uvec2 p) {
//     p = 1103515245U*((p >> 1U)^(p.yx));
//     uint h32 = 1103515245U*((p.x)^(p.y>>3U));
//     return h32^(h32 >> 16);
// }

// float g_seed = 0.;

// float hash1(inout searchInfo search) {
//     uint n = base_hash(floatBitsToUint(vec2(search.rngState+=.1,search.rngState+=.1)));
//     return float(n)/float(0xffffffffU);
// }

// vec2 hash2(inout searchInfo search) {
//     uint n = base_hash(floatBitsToUint(vec2(search.rngState+=.1,search.rngState+=.1)));
//     uvec2 rz = uvec2(n, n*48271U);
//     return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);
// }

// vec3 hash3(inout searchInfo search) {
//     uint n = base_hash(floatBitsToUint(vec2(search.rngState+=.1,search.rngState+=.1)));
//     uvec3 rz = uvec3(n, n*16807U, n*48271U);
//     return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);
// }

// vec3 random_in_unit_sphere(inout searchInfo search) {
//     vec3 h = hash3(search) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);
//     float phi = h.y;
//     float r = pow(h.z, 1./3.);
//     return r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);
// }

// uint wang_hash(inout uint seed)
// {
//     seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));
//     seed *= uint(9);
//     seed = seed ^ (seed >> 4);
//     seed *= uint(0x27d4eb2d);
//     seed = seed ^ (seed >> 15);
//     return seed;
// }

// float RandomFloat01(inout uint state)
// {
//     return float(wang_hash(state)) / 4294967296.0;
// }

// vec3 RandomUnitVector(inout uint state)
// {
//     float z = RandomFloat01(state) * 2.0f - 1.0f;
//     float a = RandomFloat01(state) * c_twopi;
//     float r = sqrt(1.0f - z * z);
//     float x = r * cos(a);
//     float y = r * sin(a);
//     return vec3(x, y, z);
// }

// struct SMaterialInfo
// {
//     vec3 albedo;           // the color used for diffuse lighting
//     vec3 emissive;         // how much the surface glows
//     float percentSpecular; // percentage chance of doing specular instead of diffuse lighting
//     float roughness;       // how rough the specular reflections are
//     vec3 specularColor;    // the color tint of specular reflections
// };

// struct SRayHitInfo
// {
//     float dist;
//     vec3 normal;
//     SMaterialInfo material;
// };

// float ScalarTriple(vec3 u, vec3 v, vec3 w)
// {
//     return dot(cross(u, v), w);
// }

// bool TestQuadTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d)
// {
//     // calculate normal and flip vertices order if needed
//     vec3 normal = normalize(cross(c-a, c-b));
//     if (dot(normal, rayDir) > 0.0f)
//     {
//         normal *= -1.0f;
        
//         vec3 temp = d;
//         d = a;
//         a = temp;
        
//         temp = b;
//         b = c;
//         c = temp;
//     }
    
//     vec3 p = rayPos;
//     vec3 q = rayPos + rayDir;
//     vec3 pq = q - p;
//     vec3 pa = a - p;
//     vec3 pb = b - p;
//     vec3 pc = c - p;
    
//     // determine which triangle to test against by testing against diagonal first
//     vec3 m = cross(pc, pq);
//     float v = dot(pa, m);
//     vec3 intersectPos;
//     if (v >= 0.0f)
//     {
//         // test against triangle a,b,c
//         float u = -dot(pb, m);
//         if (u < 0.0f) return false;
//         float w = ScalarTriple(pq, pb, pa);
//         if (w < 0.0f) return false;
//         float denom = 1.0f / (u+v+w);
//         u*=denom;
//         v*=denom;
//         w*=denom;
//         intersectPos = u*a+v*b+w*c;
//     }
//     else
//     {
//         vec3 pd = d - p;
//         float u = dot(pd, m);
//         if (u < 0.0f) return false;
//         float w = ScalarTriple(pq, pa, pd);
//         if (w < 0.0f) return false;
//         v = -v;
//         float denom = 1.0f / (u+v+w);
//         u*=denom;
//         v*=denom;
//         w*=denom;
//         intersectPos = u*a+v*d+w*c;
//     }
    
//     float dist;
//     if (abs(rayDir.x) > 0.1f)
//     {
//         dist = (intersectPos.x - rayPos.x) / rayDir.x;
//     }
//     else if (abs(rayDir.y) > 0.1f)
//     {
//         dist = (intersectPos.y - rayPos.y) / rayDir.y;
//     }
//     else
//     {
//         dist = (intersectPos.z - rayPos.z) / rayDir.z;
//     }
    
//     if (dist > c_minimumRayHitTime && dist < info.dist)
//     {
//         info.dist = dist;        
//         info.normal = normal;        
//         return true;
//     }    
    
//     return false;
// }

// bool TestSphereTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere)
// {
//     //get the vector from the center of this sphere to where the ray begins.
//     vec3 m = rayPos - sphere.xyz;

//     //get the dot product of the above vector and the ray's vector
//     float b = dot(m, rayDir);

//     float c = dot(m, m) - sphere.w * sphere.w;

//     //exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)
//     if(c > 0.0 && b > 0.0)
//         return false;

//     //calculate discriminant
//     float discr = b * b - c;

//     //a negative discriminant corresponds to ray missing sphere
//     if(discr < 0.0)
//         return false;
    
//     //ray now found to intersect sphere, compute smallest t value of intersection
//     bool fromInside = false;
//     float dist = -b - sqrt(discr);
//     if (dist < 0.0f)
//     {
//         fromInside = true;
//         dist = -b + sqrt(discr);
//     }
    
//     if (dist > c_minimumRayHitTime && dist < info.dist)
//     {
//         info.dist = dist;        
//         info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);
//         return true;
//     }
    
//     return false;
// }

// void TestSceneTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo)
// {    
//     // to move the scene around, since we can't move the camera yet
//     // vec3 sceneTranslation = vec3(0.0f, 0.0f, 10.0f);
//     // vec4 sceneTranslation4 = vec4(sceneTranslation, 0.0f);
    
//     // back wall
//     {
//         vec3 A = vec3(-12.6f, -12.6f, 25.0f);
//         vec3 B = vec3( 12.6f, -12.6f, 25.0f);
//         vec3 C = vec3( 12.6f,  12.6f, 25.0f);
//         vec3 D = vec3(-12.6f,  12.6f, 25.0f);
//         if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))
//         {
//             hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);
//             hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);
//             hitInfo.material.percentSpecular = 0.0f;
//             hitInfo.material.roughness = 0.0f;
//             hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);
//         }
//     }    
    
//     // floor
//     {
//         vec3 A = vec3(-12.6f, -12.45f, 25.0f);
//         vec3 B = vec3( 12.6f, -12.45f, 25.0f);
//         vec3 C = vec3( 12.6f, -12.45f, 15.0f);
//         vec3 D = vec3(-12.6f, -12.45f, 15.0f);
//         if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))
//         {
//             hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);
//             hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);
//             hitInfo.material.percentSpecular = 0.0f;
//             hitInfo.material.roughness = 0.0f;
//             hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);
//         }        
//     }
    
//     // cieling
//     {
//         vec3 A = vec3(-12.6f, 12.5f, 25.0f);
//         vec3 B = vec3( 12.6f, 12.5f, 25.0f);
//         vec3 C = vec3( 12.6f, 12.5f, 15.0f);
//         vec3 D = vec3(-12.6f, 12.5f, 15.0f);
//         if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))
//         {
//             hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);
//             hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);
//             hitInfo.material.percentSpecular = 0.0f;
//             hitInfo.material.roughness = 0.0f;
//             hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);
//         }        
//     }    
    
//     // left wall
//     {
//         vec3 A = vec3(-12.5f, -12.6f, 25.0f);
//         vec3 B = vec3(-12.5f, -12.6f, 15.0f);
//         vec3 C = vec3(-12.5f,  12.6f, 15.0f);
//         vec3 D = vec3(-12.5f,  12.6f, 25.0f);
//         if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))
//         {
//             hitInfo.material.albedo = vec3(0.7f, 0.1f, 0.1f);
//             hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);
//             hitInfo.material.percentSpecular = 0.0f;
//             hitInfo.material.roughness = 0.0f;
//             hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);
//         }        
//     }
    
//     // right wall 
//     {
//         vec3 A = vec3( 12.5f, -12.6f, 25.0f);
//         vec3 B = vec3( 12.5f, -12.6f, 15.0f);
//         vec3 C = vec3( 12.5f,  12.6f, 15.0f);
//         vec3 D = vec3( 12.5f,  12.6f, 25.0f);
//         if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))
//         {
//             hitInfo.material.albedo = vec3(0.1f, 0.7f, 0.1f);
//             hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);
//             hitInfo.material.percentSpecular = 0.0f;
//             hitInfo.material.roughness = 0.0f;
//             hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);
//         }        
//     }    
    
//     // light
//     {
//         vec3 A = vec3(-5.0f, 12.4f,  22.5f);
//         vec3 B = vec3( 5.0f, 12.4f,  22.5f);
//         vec3 C = vec3( 5.0f, 12.4f,  17.5f);
//         vec3 D = vec3(-5.0f, 12.4f,  17.5f);
//         if (TestQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))
//         {
//             hitInfo.material.albedo = vec3(0.0f, 0.0f, 0.0f);
//             hitInfo.material.emissive = vec3(1.0f, 0.9f, 0.7f) * 20.0f;
//             hitInfo.material.percentSpecular = 0.0f;
//             hitInfo.material.roughness = 0.0f;
//             hitInfo.material.specularColor = vec3(0.0f, 0.0f, 0.0f);
//         }        
//     }
    
//     if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-9.0f, -9.5f, 20.0f, 3.0f)))
//     {
//         hitInfo.material.albedo = vec3(0.9f, 0.9f, 0.5f);
//         hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        
//         hitInfo.material.percentSpecular = 0.1f;
//         hitInfo.material.roughness = 0.2f;
//         hitInfo.material.specularColor = vec3(0.9f, 0.9f, 0.9f);        
//     } 
    
//     if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, -9.5f, 20.0f, 3.0f)))
//     {
//         hitInfo.material.albedo = vec3(0.9f, 0.5f, 0.9f);
//         hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);   
//         hitInfo.material.percentSpecular = 0.3f;
//         hitInfo.material.roughness = 0.2;
//         hitInfo.material.specularColor = vec3(0.9f, 0.9f, 0.9f);       
//     }    
    
//     // a ball which has blue diffuse but red specular. an example of a "bad material".
//     // a better lighting model wouldn't let you do this sort of thing
//     if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(9.0f, -9.5f, 20.0f, 3.0f)))
//     {
//         hitInfo.material.albedo = vec3(0.0f, 0.0f, 1.0f);
//         hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);
//         hitInfo.material.percentSpecular = 0.5f;
//         hitInfo.material.roughness = 0.4f;
//         hitInfo.material.specularColor = vec3(1.0f, 0.0f, 0.0f);        
//     }  

//     // shiny green balls of varying roughnesses
//     {
//         if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-10.0f, 0.0f, 23.0f, 1.75f)))
//         {
//             hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);
//             hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        
//             hitInfo.material.percentSpecular = 1.0f;
//             hitInfo.material.roughness = 0.0f;
//             hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);       
//         }     
        
//         if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-5.0f, 0.0f, 23.0f, 1.75f)))
//         {
//             hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);
//             hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        
//             hitInfo.material.percentSpecular = 1.0f;
//             hitInfo.material.roughness = 0.25f;
//             hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);
//         }            
        
//         if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 0.0f, 23.0f, 1.75f)))
//         {
//             hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);
//             hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        
//             hitInfo.material.percentSpecular = 1.0f;
//             hitInfo.material.roughness = 0.5f;
//             hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);
//         }            
        
//         if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(5.0f, 0.0f, 23.0f, 1.75f)))
//         {
//             hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);
//             hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        
//             hitInfo.material.percentSpecular = 1.0f;
//             hitInfo.material.roughness = 0.75f;
//             hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);
//         }        
        
//         if (TestSphereTrace(rayPos, rayDir, hitInfo, vec4(10.0f, 0.0f, 23.0f, 1.75f)))
//         {
//             hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);
//             hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        
//             hitInfo.material.percentSpecular = 1.0f;
//             hitInfo.material.roughness = 1.0f;
//             hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);
//         }           
//     }
// }

// // void updateColor(inout SRayHitInfo hitInfo, inout searchInfo search){
// //     search.finalColor += hitInfo.emissive*search.through;
// //     search.through *= hitInfo.albedo;
// // }



// vec3 GetColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState)
// {
//     // initialize
//     vec3 ret = vec3(0.0f, 0.0f, 0.0f);
//     vec3 throughput = vec3(1.0f, 1.0f, 1.0f);
//     vec3 rayPos = startRayPos;
//     vec3 rayDir = startRayDir;
    
//     for (int bounceIndex = 0; bounceIndex <= c_numBounces; ++bounceIndex)
//     {
//         // shoot a ray out into the world
//         SRayHitInfo hitInfo;
//         hitInfo.dist = c_superFar;
//         TestSceneTrace(rayPos, rayDir, hitInfo);
        
//         // if the ray missed, we are done
//         if (hitInfo.dist == c_superFar)
//         {
//             ret += SRGBToLinear(texture(envTex, rayDir).rgb) * c_skyboxBrightnessMultiplier * throughput;
//             break;
//         }

//         // calculate whether we are going to do a diffuse or specular reflection ray 
//         float doSpecular = (RandomFloat01(rngState) < hitInfo.material.percentSpecular) ? 1.0f : 0.0f;
 
        
//         // update the ray position
//         rayPos = (rayPos + rayDir * hitInfo.dist) + hitInfo.normal * c_rayPosNormalNudge;
        
//         // Calculate a new ray direction.
//         // Diffuse uses a normal oriented cosine weighted hemisphere sample.
//         // Perfectly smooth specular uses the reflection ray.
//         // Rough (glossy) specular lerps from the smooth specular to the rough diffuse by the material roughness squared
//         // Squaring the roughness is just a convention to make roughness feel more linear perceptually.
//         vec3 diffuseRayDir = normalize(hitInfo.normal + RandomUnitVector(rngState));
//         vec3 specularRayDir = reflect(rayDir, hitInfo.normal);
//         specularRayDir = normalize(mix(specularRayDir, diffuseRayDir, hitInfo.material.roughness * hitInfo.material.roughness));
//         rayDir = mix(diffuseRayDir, specularRayDir, doSpecular);

//         // calculate new ray direction, in a cosine weighted hemisphere oriented at normal
//         // rayDir = normalize(hitInfo.normal + RandomUnitVector(rngState));        
        
//         // add in emissive lighting
//         ret += hitInfo.material.emissive * throughput;
        
//         // update the colorMultiplier
//         throughput *= mix(hitInfo.material.albedo, hitInfo.material.specularColor, doSpecular);      
    

//     // Russian Roulette
//         // As the throughput gets smaller, the ray is more likely to get terminated early.
//         // Survivors have their value boosted to make up for fewer samples being in the average.
//         {
//             float p = max(throughput.r, max(throughput.g, throughput.b));
//             if (RandomFloat01(rngState) > p)
//                 break;

//             // Add the energy we 'lose' by randomly terminating paths
//             throughput *= 1.0f / p;            
//         }
//     }
//     // return pixel color
//     return ret;
// }

// float planeIntersect(vec3 ro, vec3 rd, vec4 p){
//     return -(dot(ro, p.xyz)+p.w)/dot(rd, p.xyz);
// }

// vec2 getBokehCircle(in searchInfo search){

//     vec2 rand = hash2(search);
//     float angle = rand.x*TWOPI;
//     float radius = sqrt(rand.y);
//     return vec2(cos(angle), sin(angle))*aperture*radius;
// }

// vec2 getBokehHexa(in searchInfo search){

//     float sin30 = 0.5;
//     float cos30 = 0.866;
//     vec2 bokeh[7] = vec2[]  (   vec2(0, 1),
//                                 vec2(-cos30, sin30),
//                                 vec2(-cos30, -sin30),
//                                 vec2(0, -1),
//                                 vec2(cos30, -sin30),
//                                 vec2(cos30, sin30),
//                                 vec2(0, 1)
//                             );

//     vec2 rand = hash2(search);
//     int index = int(floor(rand.x*6));
//     float interp = fract(rand.x*6);
//     float radius = sqrt(rand.y);
//     return mix(bokeh[index], bokeh[index+1], interp)*aperture*radius;

// }

// void main()
// {
//     // SRayHitInfo hitInfo;

//     searchInfo search;

//     vec2 fragCoord = jit_in.uv * viewPort.xy;

//     // initialize a random number state based on frag coord and frame
//     uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);

//     vec2 screenPos = jit_in.uv*2 - 1;
//     float ratio = viewPort.x / viewPort.y;
//     screenPos.x *= ratio;
//     //Antialiasing
//     vec2 jittering = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f;
//     jittering /= viewPort;
//     screenPos += jittering*3;


//     // The ray starts at the camera position (the origin)
//     // vec3 rayPosition = vec3(0.0f, 0.0f, 0.0f);
//     vec3 rayPosition = eye;


//     vec3 target = vec3(0.);
//     vec3 front = normalize(target - rayPosition);
//     vec3 right = cross( vec3(0., 1., 0.), front);
//     vec3 up = cross(front, right);

//     vec3 pixPos = vec3(screenPos, 4);
//     vec3 rayDir = normalize(pixPos.x*right + pixPos.y*up + pixPos.z*front);

//     float focalDist = 0;
//     float focalPlane = planeIntersect(rayPosition, rayDir, vec4(front, DoFdist));
//     vec3 focalPoint = rayPosition + rayDir*focalPlane;

//     vec2 cameraShift = getBokehHexa(search);
//     float screenDist = planeIntersect(rayPosition, rayDir, vec4(front, 4));
//     rayPosition = eye + rayDir*screenDist;
//     rayPosition += right*cameraShift.x + up*cameraShift.y;
//     rayDir = normalize(focalPoint - rayPosition);

   
    
//     // calculate the camera distance
//     // float cameraDistance = 1.0f / tan(c_FOVDegrees * 0.5f * c_pi / 180.0f);        
    
//     // calculate coordinates of the ray target on the imaginary pixel plane.
//     // -1 to +1 on x,y axis. 1 unit away on the z axis
//     // vec3 rayTarget = vec3((fragCoord/viewPort.xy) * 2.0f - 1.0f, cameraDistance);
    
//     // correct for aspect ratio
//     // float aspectRatio = viewPort.x / viewPort.y;
//     // rayTarget.y /= aspectRatio;
    
//     // calculate a normalized vector for the ray direction.
//     // it's pointing from the ray position to the ray target.
//     // vec3 rayDir = normalize(rayTarget - rayPosition);
    
//     // raytrace for this pixel
//     vec3 color = vec3(0.0f, 0.0f, 0.0f);
//     for (int index = 0; index < c_numRendersPerFrame; ++index)
//         color += GetColorForRay(rayPosition, rayDir, rngState) / float(c_numRendersPerFrame);

//         // apply exposure (how long the shutter is open)
//     color *= c_exposure;

//     // convert unbounded HDR color range to SDR color range
//     color = ACESFilm(color);

//     // convert from linear to sRGB for display
//     // color = LinearToSRGB(color);
    
//     // average the frames together
//     // vec3 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy).rgb;
//     // color = mix(updateColor, color, 1.0f / float(sample+1));

//     // show the result
//     outColor = vec4(color, 1.0f);
// }


		]]>
		</program>
	</language>
</jittershader>
